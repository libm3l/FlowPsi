//#############################################################################
//#
//# Copyright 2018, Adam Jirasek
//#
//# This file is part of the flowPsi computational fluid dynamics solver.
//#
//# The flowPsi solver is free software: you can redistribute it and/or modify
//# it under the terms of the GNU General Public License as published by
//# the Free Software Foundation, either version 3 of the License, or
//# (at your option) any later version.
//#
//# The flowPsi solver is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# GNU General Public License for more details.
//#
//# You should have received a copy of the GNU General Public License
//# along with the flowPsi solver.  If not, see <http://www.gnu.org/licenses>
//#
//#############################################################################



/*
 * 
 * Description: calls functions acting as a bridge between FlowPsi and externally driven processes
 *     For this purpose, it uses two external libraries, libm3l and lsipdx
 *     for more details go to www.github.com/libm3l/libm3l and www.github.com/libm3l/lsipdx 
 *     values of angles, rotation center and translation
 *
 * History:
 * Version   Author:               Date       Patch number  CLA     Comment
 * -------   -------               --------   --------      ---     -------
 * 1.1       Adam Jirasek         2018-03-21                        Initial implementation
 *
 *
 *
 * 
 */

#include <Loci.h>
#include <stdio.h>
$include "flowPsi.lh"
/*
 *  include header files for libm3l and lsipdx library and header file for bridges (located in ../src_bridges)
 */
#include "libm3l.h"
#include "lsipdx.h"
#include "src_bridges.h"
#include "solverExternalComm.h"

#include <vector>
#include <list>

#ifdef LOCI_V5
#include <GLoci.h>
#endif


using std::list ;
using std::vector ;
using std::endl ;
using std::cerr ;
/* 
 * creates data sets necessary for external interfaces
 */

namespace flowPsi { 
    
     bool ident_intf(Loci::options_list::arg_list *pVol_tags, Loci::options_list ext_interfaces, 
             comm_struct_t *pcomm_str, string name, string typexternal);
/*
 * loop through list of interfaces and parse parameters
 */
    bool get_interface_info(fact_db &facts){      
    bool error = false ;
    int *proc_arr, *proc_glob_arr, gproc;
    node_t *TmpNode=NULL, *IntfNode=NULL, *DataNode=NULL, *LDataNode=NULL;
    lmsize_t dim[2];
    lmsize_t clen;
    string type;
    string bname;
    int locdomsize;
    int size_voltags;
    Loci::options_list::arg_list list_voltags ;
    
    param<options_list> bc_info, int_info ;
/*
 * get interfaces facts, if not found return
 */
    Loci::storeRepP tmp = facts.get_variable("ext_interfaces") ;
    if(tmp == 0) {
      return error;
    }

    int_info = tmp;

    error = true ;

    if(Loci::MPI_rank == 0){
       std::cout << "    " << endl ;
       std::cout << "ext_interfaces: " << endl ;
       std::cout << "---------------------" << endl ;
    }

/*
 * create structure for interfaces data
 */
    if(  (Gnode = m3l_Mklist("Interfaces", "DIR", 0, 0, (node_t **)NULL, (const char *)NULL, (const char *)NULL, (char *)NULL)) == 0)
	  Perror("m3l_Mklist");

    options_list::option_namelist nl = int_info->getOptionNameList() ;
    options_list::option_namelist::iterator li;  
/*
 * loop over all interfaces 
 */
    vector<string> intf_list_bc_names ;
/*
 * get number of interfaces 
 */
    int intf_number = 0;
/*
 * find number of MPI processes
 */
    int procs = 1 ;
    MPI_Comm_size(MPI_COMM_WORLD,&procs) ;
    int rank = 0 ;
    MPI_Comm_rank(MPI_COMM_WORLD,&rank) ;

    for(li=nl.begin();li!=nl.end();++li) {
/*
 * loop over interfaces
 */
      bname = *li ;
      Loci::option_value_type vt = int_info->getOptionValueType(bname);
      Loci::option_values ov = int_info->getOption(bname) ;
      options_list::arg_list value_list ;
      string name ;
/*
 * print interface name
 */
      if(Loci::MPI_rank == 0) std::cout << "Interface name:  " << bname << endl ;
/*
 * get options in interface
 */
      switch(vt) {
      case Loci::NAME :
        ov.get_value(name) ;
        bc_info->setOption(bname,name) ;
        break ;
      case Loci::FUNCTION:
        ov.get_value(name) ;
        ov.get_value(value_list) ;
        bc_info->setOption(bname,name,value_list) ;
        break ;
      default:
        cerr << "setup_interface can not interpret value assigned to " << bname 
             << " in ext_interfaces" << endl ;
        exit(-1) ;
      }
/*
 * parse options
 */
      options_list ol ;
      ol.Input(value_list) ;
/*
 * at the moment bcv is going to be intfr_local or intrf_global
 */
      Loci::variable bcv(name) ;
/*
 * loop through options
 */
      entitySet intsurf ;
      Loci::storeRepP sp;
      intsurf = EMPTY;

      options_list::option_namelist nlb = ol.getOptionNameList() ;
      options_list::option_namelist::iterator lii;
/*
 * loop over volume tags
 */
      for(lii=nlb.begin();lii!=nlb.end();++lii){
        size_voltags = 0;
/*
 * if option is boundary condition which is a string array defined in [], get the name of each of them
 */          
        if( *lii == "Volume_tags" ){
              ol.getOption(*lii,list_voltags) ;
              size_voltags = list_voltags.size() ;

              Loci::option_values oss = ol.getOption(*lii) ;
              if(Loci::MPI_rank == 0){
                 std::cout << "Volume tags(s) associated with interface "<<bname <<" : "<< oss << endl ;
              }
              break;
          }
      }
/*
 * if volume tags not found,, need to be specified in vars file, 
 */
      if(size_voltags == 0){
            std::cerr << "Did not find Volume_tags item for iterface "<<bname << endl ;
            std::cerr << "Check your vars file" << endl ;
            exit(-1);
      }
      
      
      for(int ivol=0;ivol<size_voltags;++ivol) {
          
         string val_tag;
         list_voltags[ivol].get_value(val_tag);
         
         if(Loci::MPI_rank == 0) std::cout << "Processing tag "<<val_tag<<" from interface "<< bname <<endl ;
 /*
 * add interface to Interfaces, make global_data DIR and add name
 */
        if(  (IntfNode = m3l_Mklist("Interface", "DIR", 0, 0, &Gnode, "/Interfaces", "./", (char *)NULL)) == 0)
		  Perror("m3l_Mklist");
        if(  (DataNode = m3l_Mklist("global_data", "DIR", 0, 0, &IntfNode, "/Interface", "./", (char *)NULL)) == 0)
		  Perror("m3l_Mklist");
        if(  (LDataNode = m3l_Mklist("local_data", "DIR", 0, 0, &IntfNode, "/Interface", "./", (char *)NULL)) == 0)
		  Perror("m3l_Mklist");
    
        const char *cstr = bname.c_str();
        clen = strlen(cstr);
        dim[0] = clen;
        if(  (TmpNode = m3l_Mklist("Name", "C", 1, dim, &IntfNode, "/Interface", "./", (char *)NULL)) == 0)
		   Error("socket_FlowPsi2simulink: m3l_Mklist");
        strncpy(TmpNode->data.c, cstr, clen);
        TmpNode->data.c[clen]='\0';
        
        const char *cstrv = val_tag.c_str();
        clen = strlen(cstrv);
        dim[0] = clen;
        if(  (TmpNode = m3l_Mklist("Volume_Tag", "C", 1, dim, &IntfNode, "/Interface", "./", (char *)NULL)) == 0)
		   Error("socket_FlowPsi2simulink: m3l_Mklist");
        strncpy(TmpNode->data.c, cstrv, clen);
        TmpNode->data.c[clen]='\0';
/*
 * allocate temporary arrays  (maybe something like std::vector<int> proc_arr(procs) ; would me more C++ like)
 */      
      if(  (proc_arr = (int *) malloc(procs * sizeof(int))) == NULL)
          cerr << "error allocating proc_arr array " << endl ;
      if(  (proc_glob_arr = (int *) malloc(procs * sizeof(int))) == NULL)
          cerr << "error allocating proc_glob_arr array " << endl ;
/*
 * set sizes of data to 0 and on root partition to -1
 */
      for(int i=0; i<procs; i++)
          proc_arr[i] = 0;
      
      if(rank == 0)proc_arr[0] = -1;
/*
 * create new extinterfaces facts 
 */
      param<string> interfaceSet ;
      *interfaceSet = bname ;
//       string factname = "extInterfaceName(Main," + bname + ")" ;
      string factname = "extInterfaceName("+val_tag+"," + bname + ")" ;
      facts.create_fact(factname,interfaceSet) ;

      int Root_ind = 0;

      param<InterfStr_t> interfaceSet_str ;
      interfaceSet_str->INTF_comm = -1;
      interfaceSet_str->INTF_Root_ind = 0;
//       factname = "extInterfaceNameStr(Main," + bname + ")" ;
      factname = "extInterfaceNameStr("+val_tag+"," + bname + ")" ;
      intf_number += 1;
      interfaceSet_str->INTF_Number = intf_number;
      interfaceSet_str->INTF_Activated = 0;

      facts.create_fact(factname,interfaceSet_str) ;     
      
      for(lii=nlb.begin();lii!=nlb.end();++lii){
/*
 * if option is boundary condition which is a string array defined in [], get the name of each of them
 */
        if( *lii == "boundary_conditions" ){

              Loci::options_list::arg_list list ;
              ol.getOption(*lii,list) ;
              int size = list.size() ;

              Loci::option_values oss = ol.getOption(*lii) ;
              if(Loci::MPI_rank == 0){
                 std::cout << "Boundary condition(s) associated with interface "<<bname <<" : "<< oss << endl ;
              }
/*
 * loop over BCs in the interface list
 */
              for(int i=0;i<size;++i) {
                string val;
                list[i].get_value(val) ;
                intf_list_bc_names.push_back(val) ;
/*
 * add to list 
 */
                sp = facts.get_variable(val) ;
                intsurf += sp->domain() ; 
/*
 * find if BCs have any point on this partionm if yes, set proc_arr[rank] = 1
 */
                Loci::entitySet dom = entitySet(sp->domain()) ;
                int np  = dom.size();
                if(np > 0) proc_arr[rank] = np;
                if(rank == 0 && np > 0)Root_ind = 1;

              }
              Loci::entitySet dom = entitySet(intsurf) ;
              interfaceSet_str->INTF_domsize = dom.size();
              locdomsize = dom.size();

        }
        else if(*lii == "type" ){
            
            ol.getOption(*lii,type) ;
            const char *cstrt = bname.c_str();
            clen = strlen(cstrt);
            dim[0] = clen;
            if(  (TmpNode = m3l_Mklist("Type", "C", 1, dim, &IntfNode, "/Interface", "./", (char *)NULL)) == 0)
		        Error("socket_FlowPsi2simulink: m3l_Mklist");
            strncpy(TmpNode->data.c, cstrt, clen);
            TmpNode->data.c[clen]='\0';
        }
      }
/*
 * if option == comm_freq, get the number
 */
        int comm_freq = 0 ;
        real param = 0;
        ol.getOptionUnits("comm_freq","",param);
        comm_freq = (int)param;
        if(Loci::MPI_rank == 0){
          if(comm_freq < 0){
            std::cout << "Required communication frequency is every " << comm_freq  <<" subiteration" <<endl;
          }
          else{
            std::cout << "Required communication frequency is every " << comm_freq  <<" iteration" <<endl;
          }
        }
/*
 * do MPI stuff
 * fill proc_arr with ranks
 */
        MPI_Allreduce(proc_arr,proc_glob_arr,procs,MPI_INT,MPI_SUM,MPI_COMM_WORLD);
/*
 * get total number of processors containing interface (root partition always included
 */
        gproc = 0;
        for(int i=0; i<procs; i++){
           if(proc_glob_arr[i] > 0 || proc_glob_arr[i] < 0){
             gproc += 1;
           } 
        }

        int *loc_proc;

        if(  (loc_proc = (int *) malloc(gproc * sizeof(int))) == NULL)
          cerr << "error allocating loc_proc array " << endl ;
/*
 * get number of processors containing interface
 */         
        gproc = 0;
        for(int i=0; i<procs; i++){
           if(proc_glob_arr[i] > 0 || proc_glob_arr[i] < 0){
             loc_proc[gproc] = i;
             gproc += 1;
           } 
        }
/*
 * get number of processors in group
 * allocate array for processors in group
 * and fill it with ranks
 *
 * create group, communicator, remove group
 */
       MPI_Group world_group;
       MPI_Group new_group;
       MPI_Comm new_comm;

       MPI_Comm_group(MPI_COMM_WORLD, &world_group );
       MPI_Group_incl(world_group, gproc, loc_proc, &new_group);
       MPI_Comm_create_group(MPI_COMM_WORLD, new_group, 0, &new_comm);
       MPI_Group_free( &new_group );
       free(loc_proc);
/*
 * this is a hack because Loci at the moment does not seem to allow 
 * having MPI_Comm as a part of compound data type nor part of the facts
 */
      interfaceSet_str->INTF_comm  = MPI_Comm_c2f(new_comm);
      interfaceSet_str->INTF_Root_ind  = Root_ind;
/*
 * count total number of elements on patition
 */
      gproc = 0;
      for(int i=0; i<procs; i++){
         if(proc_glob_arr[i] > 0){
             gproc += proc_glob_arr[i] ;
         } 
      }
      interfaceSet_str-> INTF_totdomsize = gproc;
      if(Loci::MPI_rank == 0)std::cout << "Total number of elements is " << interfaceSet_str-> INTF_totdomsize<< endl ;
/*
 * add all intsurf to a newly created constraint ConstextInterfaceName_X
 */
        constraint bc_constraint ;
        *bc_constraint = intsurf;
        std::string constraint_name = "LocConstextInterfaceName(Main," + bname + ")" ;
        facts.create_fact(constraint_name,bc_constraint) ;

        entitySet intsurfall = all_collect_entitySet(intsurf) ;
/*
 * do some stdout write out
 */
        if(Loci::MPI_rank == 0)std::cout << bname << " " << intsurfall << endl ;

        *bc_constraint = intsurfall;
        constraint_name = "ConstextInterfaceName("+val_tag+"," + bname + ")" ;
        facts.create_fact(constraint_name,bc_constraint) ;

        if(Loci::MPI_rank == 0)std::cout << "    " << endl ;
/*
 * add data based on type of interface
 */
       if(type == "aeroelasticity"){
/*
 * aeroelastic interface
 * add forces and displacements
 */        
         dim[0] = locdomsize;
         dim[1] = 3;
/*
 * create and store double array of 6 with name ForcesMoments in CFD_2_SIM
 */
  	     if(  (TmpNode = m3l_Mklist("Forces", "D", 2, dim, &LDataNode, "./local_data", "./", (char *)NULL)) == 0)
  		    Error("socket_FlowPsi2simulink: m3l_Mklist");
	     if(  (TmpNode = m3l_Mklist("disps", "D", 2, dim, &LDataNode, "./local_data", "./", (char *)NULL)) == 0)
		     Error("socket_FlowPsi2simulink: m3l_Mklist");
           
         if(Loci::MPI_rank == 0){
             
            dim[0] = gproc;
            dim[1] = 3;
/*
 * create and store double array of 6 with name ForcesMoments in CFD_2_SIM
 */
  	       if(  (TmpNode = m3l_Mklist("Forces", "D", 2, dim, &DataNode, "./global_data", "./", (char *)NULL)) == 0)
  		     Error("socket_FlowPsi2simulink: m3l_Mklist");
	       if(  (TmpNode = m3l_Mklist("disps", "D", 2, dim, &DataNode, "./global_data", "./", (char *)NULL)) == 0)
		     Error("socket_FlowPsi2simulink: m3l_Mklist");
           
           dim[0] = 1;
           if(  (TmpNode = m3l_Mklist("size", "ST", 1, dim, &DataNode, "./global_data", "./", (char *)NULL)) == 0)
		     Error("socket_FlowPsi2simulink: m3l_Mklist");
           TmpNode->data.st[0] = gproc;
           if(  (TmpNode = m3l_Mklist("time", "D", 1, dim, &DataNode, "./global_data", "./", (char *)NULL)) == 0)
		     Error("socket_FlowPsi2simulink: m3l_Mklist");
           TmpNode->data.df[0] = 0;
         }

       }
       else if(type == "aeroelasticity_rigid"){
/*
 * aeroelastic interface
 * add forces and displacements
 */        
         dim[0] = locdomsize;
         dim[1] = 3;
/*
 * create and store double array of 6 with name ForcesMoments in CFD_2_SIM
 */
  	     if(  (TmpNode = m3l_Mklist("Forces", "D", 2, dim, &LDataNode, "./local_data", "./", (char *)NULL)) == 0)
  		    Error("socket_FlowPsi2simulink: m3l_Mklist");
           
         if(Loci::MPI_rank == 0){
             
            dim[0] = gproc;
            dim[1] = 3;
/*
 * create and store double array of 6 with name ForcesMoments in CFD_2_SIM
 */
  	       if(  (TmpNode = m3l_Mklist("Forces", "D", 2, dim, &DataNode, "./global_data", "./", (char *)NULL)) == 0)
  		     Error("socket_FlowPsi2simulink: m3l_Mklist");
           
//    	       if(  (TmpNode = m3l_Mklist("global_index", "ST", 1, dim, &DataNode, "./global_data", "./", (char *)NULL)) == 0)
//   		     Error("socket_FlowPsi2simulink: m3l_Mklist");          
           
           dim[0] = 1;
           if(  (TmpNode = m3l_Mklist("size", "ST", 1, dim, &DataNode, "./global_data", "./", (char *)NULL)) == 0)
		     Error("socket_FlowPsi2simulink: m3l_Mklist");
           TmpNode->data.st[0] = gproc;
           
           if(  (TmpNode = m3l_Mklist("time", "D", 1, dim, &DataNode, "./global_data", "./", (char *)NULL)) == 0)
		     Error("socket_FlowPsi2simulink: m3l_Mklist");
           TmpNode->data.df[0] = 0;
         }

       }
/*
 * free memory
 */
       free(proc_arr);
       free(proc_glob_arr);
       
      }
    
    }

    return error ;
  };
  
  
  
  
  
/*
 * function loops over interfaces, find if there is associated tag 
 */
     bool ident_intf(Loci::options_list::arg_list *pVol_tags, Loci::options_list ext_interfaces, 
                     comm_struct_t *pcomm_str, string name, string typexternal){
/*
 * get pointer on interfaces in facts 
 */
      param<options_list> int_info ;
      int_info = ext_interfaces;

      options_list::option_namelist nl = int_info->getOptionNameList() ;
      options_list::option_namelist::iterator li;
      
      const lmchar_t *cp;
      lmsize_t clen;
      int found;
/*
 * set li to the beginning of list of interfaces
 */
      li = nl.begin();
      string bname; 
      found = 0;
/*
 * set li to the beginning of interface list
 */
      for(li=nl.begin();li!=nl.end();++li) {
/*
 * this is name of interface
 */
        bname = *li ;
/*
 * if not requested interface, skip the rest of the loop
 */
        if(*li != name)continue;
        
        found = 1;

        cp = bname.c_str();
        clen = strlen(cp);
        strncpy(pcomm_str->intf_name, cp, clen);
        pcomm_str->intf_name[clen] = '\0';

        Loci::option_value_type vt = int_info->getOptionValueType(bname);
        Loci::option_values ov = int_info->getOption(bname) ;
        options_list::arg_list value_list ;
        string name ;
/*
 * get options in intf
 */
      param<options_list> bc_info;
      switch(vt) {
      case Loci::NAME :
        ov.get_value(name) ;
        bc_info->setOption(bname,name) ;
        break ;
      case Loci::FUNCTION:
        ov.get_value(name) ;
        ov.get_value(value_list) ;
        bc_info->setOption(bname,name,value_list) ;
        break ;
      default:
        cerr << "setup_interface can not interpret value assigned to " << bname 
             << " in ext_interfaces" << endl ;
        exit(-1) ;
      }
/*
 * parse options
 */
      options_list ol ;
      ol.Input(value_list) ;
/*
 * at the moment bcv is going to be intfr_local or intrf_global
 */
      Loci::variable bcv(name) ;
/*
 * loop through options 
 */
      options_list::option_namelist nlb = ol.getOptionNameList() ;
      Loci::option_values oss;

      double param;
      string type, tag,I_channel, O_channel, intf_name,IP, BCs, I_channel_name, O_channel_name;

      options_list::option_namelist::iterator lii;
      for(lii=nlb.begin();lii!=nlb.end();++lii){ 

        if( *lii == "boundary_conditions" ){
            oss = ol.getOption(*lii) ;
            ol.getOption(*lii,BCs);
        }
        else if(*lii == "I_channel" ){
            bzero(pcomm_str->I_channel,80);
            ol.getOption(*lii,I_channel_name) ;
            cp =  I_channel_name.c_str();
            clen = strlen(cp);
            strncpy(pcomm_str->I_channel, cp, clen);
            pcomm_str->I_channel[clen] = '\0';
        }
        else if(*lii == "O_channel" ){
            bzero(pcomm_str->O_channel,80);
	        ol.getOption(*lii,O_channel_name) ;
            cp =  O_channel_name.c_str();
            clen = strlen(cp);
            strncpy(pcomm_str->O_channel, cp, clen);
            pcomm_str->O_channel[clen] = '\0';
        }
        else if(*lii == "Volume_tags" ){
            oss = ol.getOption(*lii) ;
	        ol.getOption(*lii,*pVol_tags) ;
        }
        else if(*lii == "type" ){
            bzero(pcomm_str->type,80);
            ol.getOption(*lii,type) ;
            cp =  type.c_str();
            clen = strlen(cp);
            strncpy(pcomm_str->type, cp, clen);
            pcomm_str->type[clen] = '\0';
            
            if(pcomm_str->type != typexternal)found = 0;
        }
        else if(*lii == "IP" ){
            bzero(pcomm_str->IP,80);
            ol.getOption(*lii,IP) ;
            cp =  IP.c_str();
            clen = strlen(cp);
            strncpy(pcomm_str->IP, cp, clen);
            pcomm_str->IP[clen] = '\0';  
        }
      }
/*
 * get value of comm_freq from interface
 */
      ol.getOptionUnits("comm_freq","",param);
      pcomm_str->comm_freq = (int)param;
/*
 * get port number
 */
      ol.getOptionUnits("portno","",param);
      pcomm_str->portno = (int)param;

      if(found == 0){
         return true;  /* specified interface not found, return*/
      }
      else{
         return true;  /* specified interface found, return*/
      }

  } 
  
  return false;  /* put this statement here to avoid having warning message during compillation*/

 };
}




