//#############################################################################
//#
//# Copyright 2018, Adam Jirasek
//#
//# This file is part of the flowPsi computational fluid dynamics solver.
//#
//# The flowPsi solver is free software: you can redistribute it and/or modify
//# it under the terms of the GNU General Public License as published by
//# the Free Software Foundation, either version 3 of the License, or
//# (at your option) any later version.
//#
//# The flowPsi solver is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# GNU General Public License for more details.
//#
//# You should have received a copy of the GNU General Public License
//# along with the flowPsi solver.  If not, see <http://www.gnu.org/licenses>
//#
//#############################################################################



/*
 * 
 * Description: calls functions acting as a bridge between FlowPsi and externally driven processes
 *     For this purpose, it uses two external libraries, libm3l and lsipdx
 *     for more details go to www.github.com/libm3l/libm3l and www.github.com/libm3l/lsipdx 
 *     values of angles, rotation center and translation
 *
 * CHANGELOG:
 * Version   Author:               Date       Patch number  CLA     Comment
 * -------   -------               --------   --------      ---     -------
 * 1-beta-6  Adam Jirasek         2018-03-21                        Initial Implementation
 *
 *
 *
 * 
 */
#include "libm3l.h"
#include "lsipdx.h"

#include <Loci.h>
#include <stdio.h>
$include "flowPsi.lh"

#include "gridComponent.h"
#include "extcomm_def.h"
#include "src_bridges_types.h"
#include "solverExternalComm.h"

#include <vector>
#include <list>
#include <string.h>
#include <map>
using std::map ;

using std::list ;
using std::vector ;
using std::endl ;
using std::cerr ;
using std::cout ;
using Loci::MPI_rank ;

#ifdef LIBM3LSIPDX
/*
 * compile with libm3l and lsipdx support
 *
 *  include header files for libm3l and lsipdx library and header file for bridges (located in ../src_bridges)
 */
#include "src_bridges.h"
#include "libm3l.h"
#include "lsipdx.h"
/* 
 * declarations
 */
$type extInterfaceName(X,Y) param<string>;
$type ConstextInterfaceName(X,Y) constraint;
$type extInterfaceNameStr(X,Y)  param<InterfStr_t>;
$type componentName_X blackbox<string> ;

$type componentExternalRigid_X Constraint ;
$type componentExternalElastic_X Constraint ;
$type componentExternalMotion_X Constraint ;

$type localvec store<Loci::vector3d<Loci::real_t> > ;

node_t *Gnode;

namespace flowPsi { 

   bool ident_intf(Loci::options_list::arg_list *pVol_tags, Loci::options_list ext_interfaces, 
                      comm_struct_t *pcomm_str, string name, string type);
      
   $rule optional(ext_interfaces) {}
   
/*
 * these are gather and scatter routines s
 */
void  GatherDVec(lmdouble_t *gv, lmdouble_t *v, int len, MPI_Comm comm) {
	int procs = 1 ;
	MPI_Comm_size(comm,&procs) ;
/*
 * gather sizes of vectors on root partition
 */
	std::vector<int> part_sizes(procs) ;
	MPI_Gather(&len,1,MPI_INT, &part_sizes[0],1,MPI_INT,0,comm) ;
/*
 * get vector of displacements
 */
	std::vector<int> displs(procs) ;
        
	displs[0] = 0 ;
	for(int i=1;i<procs;++i)
		displs[i] = displs[i-1]+part_sizes[i-1];
/*
 * gather data
 */
	MPI_Gatherv(&v[0],len,MPI_DOUBLE,&gv[0],&part_sizes[0],&displs[0],MPI_DOUBLE,
			0, comm) ;
}

void  ScatterDVec(lmdouble_t *gv, lmdouble_t *v, int len, MPI_Comm comm) {
	int procs = 1 ;
	MPI_Comm_size(comm,&procs) ;
/*
 * gather sizes of vectors on root partition
 */
	std::vector<int> part_sizes(procs) ;
	MPI_Gather(&len,1,MPI_INT, &part_sizes[0],1,MPI_INT,0,comm) ;
/*
 * get vector of displacements
 */
	std::vector<int> displs(procs) ;
        
	displs[0] = 0 ;
	for(int i=1;i<procs;++i)
		displs[i] = displs[i-1]+part_sizes[i-1];
/*
 * scatter data
 */
	MPI_Scatterv(&gv[0],&part_sizes[0],&displs[0],MPI_DOUBLE,
			&v[0],len,MPI_DOUBLE,0, comm) ;
}
  
  $type numDeformNodes   param<size_t>;
  $type InterfaceIO  blackbox<int>; 
  
  $rule unit( numDeformNodes ),
		constraint( UNIVERSE ) {
	$numDeformNodes = 0;
}
/*
 * count number of elements 
 */
  $rule unit(InterfaceIO <- numDeformNodes,face2node, volumeTag(X), extInterfaceName(X,Y) ),
	option(disable_threading),constraint( ConstextInterfaceName(X,Y),volumeTag(X)),parametric(extInterfaceName(X,Y)),
    prelude {  
     
//          node_t *TmpNode=NULL;
         Loci::storeRepP sp;
         Loci::fact_db* facts = Loci::exec_current_fact_db ;

         string str_intfname =  *$extInterfaceName(X,Y) ;
         string str_voltagname =  *$volumeTag(X) ;
        
         string IntfName = "LocConstextInterfaceName("+str_voltagname+","+str_intfname+")"; 
         Loci::fact_db::distribute_infoP df = 0;         
         if(facts->is_distributed_start())
	       df = facts->get_distribute_info();

         sp = facts->get_variable(IntfName) ;
         Loci::entitySet dom = entitySet(sp->domain()) ;
         
         if(df!=0) {
	       dom &= df->my_entities ;
         }

         int ntri = 0 ;
	     int nqua = 0 ;
	     int ngen = 0 ; // TODO: Add support for arbitrary-sized faces
         FORALL(dom, ii) {
		    if ($face2node[ii].size() == 3)
		      ntri++ ;
		    else if ($face2node[ii].size() == 4)
			   nqua++ ;
		    else
			   ngen++ ;
	      } ENDFORALL ;
          
          printf(" COUNT -----------------   %d   %d   %d   %d  \n", Loci::MPI_rank,ntri, nqua, ngen);
         
         if(Loci::MPI_rank==0){
        
          std::cout << "CREATING GNODE===================================================================== "<<  ::endl ;
 
// 	      if(  (Gnode = m3l_Mklist("Interfaces", "DIR", 0, 0, (node_t **)NULL, (const char *)NULL, (const char *)NULL, (char *)NULL)) == 0)
// 		    Perror("m3l_Mklist");
          
//           if(  (TmpNode = m3l_Mklist("IIII", "DIR", 0, 0, &Gnode, "/Interfaces", "./", (char *)NULL)) == 0)
// 		  Perror("m3l_Mklist");
        }
    };
    
    
    
      $rule unit(InterfaceIO <- numDeformNodes),
	option(disable_threading),constraint( UNIVERSE ),
    prelude {  
        
          std::cout << "CREATING GNODE===================================================================== "<<  ::endl ;
 
// 	      if(  (Gnode = m3l_Mklist("Interfaces", "DIR", 0, 0, (node_t **)NULL, (const char *)NULL, (const char *)NULL, (char *)NULL)) == 0)
// 		    Perror("m3l_Mklist");
          
//           if(  (TmpNode = m3l_Mklist("IIII", "DIR", 0, 0, &Gnode, "/Interfaces", "./", (char *)NULL)) == 0)
// 		  Perror("m3l_Mklist");
        
    };
    
    
/*
 * 
 * componentExternal is set always when interface calls for external communication
 * it is set in gridComponents.loci
 */  
 $type componentName_X blackbox<string> ;
/*
 * values of the componentName_X which is the same as volumeTag,
 * and is with the $componentExternalRigid_X which indicates the tag communicates 
 * externally set in gridComponent.loci
 */

/*
 * this is a temporary hack which makes the comm rule always executed
 * find out how to replace by conditional($extInterfaceNameStr(X).INTF_docommunicate)
 */
  $type docom param<bool>;
  $rule default(docom){
      $docom=true;
  }

  $type docomappl param<bool>;
  $rule default(docomappl){
      $docomappl=false;
  }
/*
 * execute interfaces
 *
 * Prescribed Quaternion interface
 */
//     $rule singleton(OUTPUT<-ncycle,volumeTag(X),
//     extInterfaceNameStr(X,Y),extInterfaceName(X,Y),ext_interfaces),
//     constraint(ConstextInterfaceName(X,Y),volumeTag(X)),conditional(docom),
//     parametric(extInterfaceNameStr(X,Y)){
//     
//        if( $extInterfaceNameStr(X,Y).INTF_docommunicate){
//            std::cout << "COMM1111111111111111  - " << $extInterfaceName(X,Y)  << "    " << ($extInterfaceNameStr(X,Y)).INTF_docommunicate<<  " Volume tag: " << $volumeTag(X) <<  ::endl ;
//        }
//   }

  $type docommnit param<bool> ;
  $type docomm{n,it} param<bool> ;

  
  $rule singleton(docomm{n,it}<-ncycle{n},print_freq,$it{n,it}) {
    //the condition for dumping out cfl information
    // print out cfl when we are dumping an output file (ncyc % print_freq) == 0
    // and we are on the first newton iteration
    $docomm{n,it} = ($ncycle{n} % 1) == 0 && ($$it{n,it} %1) ;
          std::cout << " In doooooooooooooooooooooooooooo     - " << $docomm{n,it} <<std::endl ;

  }

/*
 * rigid body motion interface
 */
   $rule apply(componentMotionData<-ncycle, stime, dtmax,ext_interfaces,extInterfaceNameStr(X,Y),
                 componentName_X,extInterfaceName(X,Y),volumeTag(X))[Loci::NullOp], 
                 parametric(extInterfaceName(X,Y)),
                 constraint(ConstextInterfaceName(X,Y),volumeTag(X),componentExternalRigid_X), 
                 conditional(docom),
                 prelude{
/*
 * if interface is "active" communicate
 */
    if(Loci::MPI_rank==0) 
      std::cout << "COAPLYYYYYYYYYYYYY  - " << $extInterfaceName(X,Y)  << "    " << $volumeTag(X) <<  "  BOOL:  " << (*$extInterfaceNameStr(X,Y)).INTF_docommunicate << "   NCYCLE: " << *$ncycle   << std::endl ;
      
      if(Loci::MPI_rank==0) 
         m3l_Cat(Gnode, "--detailed", "-L", "-P", "*",   (lmchar_t *)NULL);

//       for(int i=0; i < len;i++){
//                 std::cout << "COOOOOOOOORDS  " << $localvec[i] << "    " << std::endl ;
//       }
/*
 * loop over fact database with interfaces and find if it is there
 */
      comm_struct_t comm_str, *pcomm_str;
      pcomm_str = &comm_str;

      int comm_interface;
      comm_interface = 0;
/*
 * set defaults
 */      
//       (*$extInterfaceNameStr(X,Y)).INTF_docommunicate = false;
      string commtype;
      Loci::options_list::arg_list Vol_tags, *pVol_tags;
      pVol_tags = &Vol_tags;

      if(Loci::MPI_rank==0) {
        std::cout << "Looking for interface  - " <<  *$extInterfaceName(X,Y)  << std::endl ; 
/*
 * identify interface
 */
        if( ident_intf(pVol_tags, *$ext_interfaces, pcomm_str, *$extInterfaceName(X,Y), "prescribed_quaternion")){
/*
 * check that type among allowed types of interfaces
 */
          lmsize_t clen = strlen(pcomm_str->type);
          if( strncmp(pcomm_str->type, "prescribed_quaternion", clen) != 0 &&
              strncmp(pcomm_str->type, "test_interface", clen) != 0) {

            std::cerr << "ERROR: unknown type of interface (1) '" << pcomm_str->type << "', check settings in .vars file" << std::endl ;
            exit(-1) ;

          }
/*
 * set if to communicate
 */
//           if(pcomm_str->comm_freq < 0){
//             if(  (*$$it % pcomm_str->comm_freq) == 0 )comm_interface = 1;
//           }
//           else{
//             if ( (*$ncycle % pcomm_str->comm_freq) == 0 && (*$$it == 0) )  comm_interface = 1;;
//           }
        }
        else{
            std::cerr << "ERROR: did not find interface - " << *$extInterfaceName(X,Y)  << " - , check settings in .vars file" << std::endl ;
            exit(-1) ;
        }
       }
/* 
 * broadcast comm_interface
 */
        MPI_Bcast(&comm_interface,1,MPI_INTEGER,0,MPI_COMM_WORLD) ;
        if(comm_interface == 1){
/*
 * if comm_interface == 1 broadcast pcomm_str
 */
           MPI_Bcast(pcomm_str->type,80,MPI_CHAR,0,MPI_COMM_WORLD) ;
           commtype = pcomm_str->type;

            if(Loci::MPI_rank==0)   std::cout << "communication  - " << commtype  << " and char " << pcomm_str->type << endl ;

           if(commtype.compare("prescribed_quaternion") == 0){
    //           $extInterfaceNameStr(X,Y).INTF_docommunicate = true;
           } 
           else if(commtype.compare("test_interface") == 0 ){
     //          $extInterfaceNameStr(X,Y).INTF_docommunicate = true;
           }
           else{
              std::cerr << "ERROR: did not find communication type (2) - " << commtype  << " - , check settings in .vars file" << std::endl ;
              exit(-1) ;
           }

        }

  //    if( (*$extInterfaceNameStr(X,Y)).INTF_docommunicate){    

        vect3d cg = vect3d (1.0,1.0,1.0) ;
        vect3d cg_new;
/*
 * get simulation time
 */
        real t = *$stime + *$dtmax ;

        lmdouble_t RotCX, RotCY,  RotCZ;
        lmdouble_t TransX, TransY, TransZ;
        lmdouble_t Alpha, Qx, Qy, Qz;
        lmdouble_t ForceX, ForceY, ForceZ;

        Loci::options_list::arg_list list ;
        options_list::arg_list value_list ;
        componentXform xform ;

        if(Loci::MPI_rank==0) {
/*
 * communicate, if interface found, execute it, all checks were done before this rule
 */
           if(ident_intf(pVol_tags, *$ext_interfaces, pcomm_str,*$extInterfaceName(X,Y), "prescribed_quaternion")){
/*
 * this is rigid body motion interface, sends away forces and gets back quaternion, translation and 
 * center of rotation
 */
               bridge_prescribed_quaternion(t, ForceX, ForceY, ForceZ, &Alpha, &Qx, &Qy, &Qz,
                   &TransX, &TransY, &TransZ, &RotCX, &RotCY, &RotCZ, pcomm_str);
            }
        }
/*
 * broadcast and save in XmotionData structure
 */
        MPI_Bcast(&TransX,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&TransY,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&TransZ,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&RotCX,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&RotCY,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&RotCZ,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&Alpha,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&Qx,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&Qy,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&Qz,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;

        cg     = vect3d(RotCX, RotCY, RotCZ);
        cg_new = vect3d(TransX, TransY, TransZ);
        cg_new = cg + cg_new;

        xform.cg = cg;
        xform.new_cg = cg_new ;
        xform.q.x = Qx ;
        xform.q.y = Qy ;
        xform.q.z = Qz ;
        xform.q.w = Alpha;
/*
 * loop over volume tags and set componentMotionData
 */
        int size = Vol_tags.size() ;
        string name, name1;
/*
 * loop over volume tags
 */
       options_list ol ;
       ol.Input(Vol_tags);
       options_list::option_namelist nlb = ol.getOptionNameList() ; 
       options_list::option_namelist::iterator lii;
//       
//          for(lii=nlb.begin();lii!=nlb.end();++lii){ 
//            name1 = *lii;
           name = *$componentName_X;
            std::cout << "TAGGGGGGGGGGGGG  - " << Loci::MPI_rank << "   " << "'"<<name1<<"    "<< name << " SIZE " << (*$extInterfaceNameStr(X,Y)).INTF_domsize<<std::endl ;
          (*$componentMotionData)[name] = xform;
//         }  
    //  }
   };
   
   
   

/*
 * elastic body motion interface
 * ====================================================================================
 */
   $rule apply(componentMotionData<-ncycle, stime, dtmax,ext_interfaces,extInterfaceNameStr(X,Y),
                 componentName_X,extInterfaceName(X,Y),volumeTag(X),ConstextInterfaceName(X,Y),
                 face2node, pos,facecenter,area)[Loci::NullOp], 
                 parametric(extInterfaceName(X,Y)),
                 constraint(ConstextInterfaceName(X,Y),volumeTag(X),componentExternalElastic_X), 
                 conditional(docom),
                 prelude{
/*
 * if interface is "active" communicate
 */
    find_t *Founds=NULL;
    node_t *IntfNode, *Snode, *local_data, *global_data, *FoundNode;
    char buffer [80];
    lmdouble_t *forces, *displacements, *forcesg, *displacementsg; 
    
    if(Loci::MPI_rank==0) 
      std::cout << "COAPLYYYYYYYYYYYYY- AEROELS  - " << $extInterfaceName(X,Y)  << "    " << $volumeTag(X) <<  "  BOOL:  " << (*$extInterfaceNameStr(X,Y)).INTF_docommunicate << "   NCYCLE: " << *$ncycle   << std::endl ;
    
     if(Loci::MPI_rank==0) 
         m3l_Cat(Gnode, "--detailed", "-L", "-P", "*",   (lmchar_t *)NULL);
/*
 * find interface with file Name with name *$extInterfaceName(X,Y) in it
 */
       string str_intfname =  *$extInterfaceName(X,Y) ;
       string str_voltagname =  *$volumeTag(X) ;
       const char *srt = str_intfname.c_str(); 
       sprintf (buffer, "/*/SV_Name=%s", srt);
/*
 * locate interface, clean allocated memory
 */      
      if( (Founds = m3l_Locate(Gnode, "/Interfaces/Interface", buffer,  (lmchar_t *)NULL)) != NULL){
          
          IntfNode = m3l_get_Found_node(Founds, 0);
          m3l_DestroyFound(&Founds);

      }
      else{
          Perror("Did not find aeroleastic interface");
      }
/*
 * loop over fact database with interfaces and find if it is there
 */
      comm_struct_t comm_str, *pcomm_str;
      pcomm_str = &comm_str;

      int comm_interface;
      comm_interface = 1;
      Loci::storeRepP sp;
      Loci::fact_db* facts = Loci::exec_current_fact_db ;
/*
 * set defaults
 */      
/*
 * get simulation time
 */
        real t = *$stime + *$dtmax ;

    //       (*$extInterfaceNameStr(X,Y)).INTF_docommunicate = false;
      string commtype;
      Loci::options_list::arg_list Vol_tags, *pVol_tags;
      pVol_tags = &Vol_tags;
      
      if(Loci::MPI_rank==0) {
        std::cout << "Looking for interface  - " <<  *$extInterfaceName(X,Y)  << std::endl ; 
/*
 * identify interface
 */
        if( ident_intf(pVol_tags, *$ext_interfaces, pcomm_str, *$extInterfaceName(X,Y), "aeroelasticity")){
/*
 * check that type among allowed types of interfaces
 */
          lmsize_t clen = strlen(pcomm_str->type);
          if(strncmp(pcomm_str->type, "aeroelasticity", clen) != 0 ){

            std::cerr << "ERROR: unknown type of interface (3-1) '" << pcomm_str->type << "', check settings in .vars file" << std::endl ;
            exit(-1) ;

          }
        }
        else{
            std::cerr << "ERROR: did not find interface - " << *$extInterfaceName(X,Y)  << " - , check settings in .vars file" << std::endl ;
            exit(-1) ;
        }
       }
/* 
 * broadcast comm_interface
 */
        MPI_Bcast(&comm_interface,1,MPI_INTEGER,0,MPI_COMM_WORLD) ;
        if(comm_interface == 1){
/*
 * if comm_interface == 1 broadcast pcomm_str
 */
           MPI_Bcast(pcomm_str->type,80,MPI_CHAR,0,MPI_COMM_WORLD) ;
           commtype = pcomm_str->type;

            if(Loci::MPI_rank==0)   std::cout << "communication  - " << commtype  << " and char " << pcomm_str->type << endl ;

           if(commtype.compare("aeroelasticity") == 0){
    //           $extInterfaceNameStr(X,Y).INTF_docommunicate = true;
           } 
           else{
              std::cerr << "ERROR: did not find communication type (3) - " << commtype  << " - , check settings in .vars file" << std::endl ;
              exit(-1) ;
           }

        }
        
        int len = (*$extInterfaceNameStr(X,Y)).INTF_domsize;

        string IntfName = "LocConstextInterfaceName("+str_voltagname+","+str_intfname+")"; 
        Loci::fact_db::distribute_infoP df = 0;         
        if(facts->is_distributed_start())
	      df = facts->get_distribute_info();

        sp = facts->get_variable(IntfName) ;
        Loci::entitySet intsurf = entitySet(sp->domain()) ;
         
        if(df!=0) {
	       intsurf &= df->my_entities ;
        }
/*
 * find vector of local forces and displacements, on the root partition,find 
 * global vectors too. Omit all checks, proper coding would require to so si
 */
        Founds = m3l_Locate(IntfNode, "./Interface/local_data", "/*/*",  (lmchar_t *)NULL);
/*
 */
        local_data = m3l_get_Found_node(Founds, 0);
        m3l_DestroyFound(&Founds);
        
        Founds = m3l_Locate(local_data, "./local_data/Forces", "/*/*",  (lmchar_t *)NULL);
/*
 */	
        FoundNode = m3l_get_Found_node(Founds, 0);
        forces =(lmdouble_t *)m3l_get_data_pointer(FoundNode);
        m3l_DestroyFound(&Founds);
        
        Founds = m3l_Locate(local_data, "./local_data/disps", "/*/*",  (lmchar_t *)NULL);
/*
 */
        FoundNode = m3l_get_Found_node(Founds, 0);
        displacements =(lmdouble_t *)m3l_get_data_pointer(FoundNode);
        int  tot_dim = m3l_get_List_totdim(FoundNode);
        
        m3l_DestroyFound(&Founds);
        
        if(Loci::MPI_rank==0) {
          Founds = m3l_Locate(IntfNode, "./Interface/global_data", "/*/*",  (lmchar_t *)NULL);
/*
 */
          global_data = m3l_get_Found_node(Founds, 0);
          m3l_DestroyFound(&Founds);
        
          Founds = m3l_Locate(global_data, "./global_data/Forces", "/*/*",  (lmchar_t *)NULL);
/*
 */
          FoundNode = m3l_get_Found_node(Founds, 0);
          forcesg =(lmdouble_t *)m3l_get_data_pointer(FoundNode);
          m3l_DestroyFound(&Founds);

          Founds = m3l_Locate(global_data, "./global_data/disps", "/*/*",  (lmchar_t *)NULL);
/*
 */
          FoundNode = m3l_get_Found_node(Founds, 0);
          displacementsg =(lmdouble_t *)m3l_get_data_pointer(FoundNode);
          
          int  tot_dim1 = m3l_get_List_totdim(FoundNode);
          m3l_DestroyFound(&Founds);
            
        }


        int cnt = 0 ; 
        int lenvec = len *3;

        FORALL(intsurf,ii) {
//           vect3d p1 = $pos[$face2node[ii][0]] ;
//           vect3d p2 = $pos[$face2node[ii][1]] ;
//           vect3d p3 = $pos[$face2node[ii][2]] ;
//           vect3d p4 = $pos[$face2node[ii][3]] ;
            
            int ind1 = m3l_get_2ind(cnt,0,len,3);
            int ind2 = m3l_get_2ind(cnt,1,len,3);
            int ind3 = m3l_get_2ind(cnt,2,len,3);

            forces[ind1] = $facecenter[ii].x;
            forces[ind2] = $facecenter[ii].y;
            forces[ind3] = $facecenter[ii].z;
            
		    cnt++ ;
            
//             std::cout << "AREA  " <<  $area[ii] <<endl ;
//             std::cout <<   $iflux[ii+0] << "  " << $iflux[ii+1] << "  " << $iflux[ii+2] <<endl ;

        }ENDFORALL ;         
/*
 * gather data
 */         
        MPI_Comm comm  = MPI_Comm_f2c((*$extInterfaceNameStr(X,Y)).INTF_comm);
        GatherDVec(forcesg, forces, lenvec, comm);

        if(Loci::MPI_rank==0) {
             
           for(lmsize_t i = 0 ; i< (*$extInterfaceNameStr(X,Y)).INTF_totdomsize; i++){
           
               int ind1 = m3l_get_2ind(i,0,len,3);
               int ind2 = m3l_get_2ind(i,1,len,3);
               int ind3 = m3l_get_2ind(i,2,len,3);
          
//                std::cout << "PNE "  << i << "  "<< forcesg[ind1]  << " " << forcesg[ind2] << " " << forcesg[ind3]  <<endl ;
           }
/*
 * this is rigid body motion interface, sends away forces and gets back quaternion, translation and 
 * center of rotation
 */
           Snode = bridge_aeroelastic(IntfNode, pcomm_str);

           if(m3l_Umount(&Snode) != 1)
		     Perror("solverExternalComm - aeroelastic: m3l_Umount");
        }
/*
 * scatter data
 */        
        ScatterDVec(displacementsg, displacements, lenvec, comm);
        
   };
/*
 * elastic body motion interface
 * ====================================================================================
 */



//     $rule pointwise(localvec<-ncycle,facecenter),
//      constraint(ConstextInterfaceName(X,Y)),parametric(extInterfaceName(X,Y))
//      {
// /*
//  * get number of points on boundaries in interface
//  */         
//          std::cout << "asigning        - " << Loci::MPI_rank << "   " << std::endl ;
// 
//         $localvec = $facecenter;
//         };
   
//    $rule pointwise(OUTPUT<-ncycle,temperature_f, u_f,facecenter,gagePressure_f),
//     constraint(ConstextInterfaceName(X,Y)),parametric(extInterfaceName(X,Y))
//     {
// /*
//  * get number of points on boundaries in interface
//  */
//      cout << "RANK " << Loci::MPI_rank << " Cycle " << " INTF is "<<   $ncycle << "  " <<  $temperature_f << "  " << $facecenter<< endl;
//     };
    

}


#else
/*
 * in case of not having libm3l and lsipdx 
 */
namespace flowPsi { 


  $rule singleton(XmotionData(X)<-dtmax,stime), 
    constraint(componentExternalRigid_X),parametric(volumeTag(X)){
    if(Loci::MPI_rank==0) {
      cerr << " " << endl ;
      cerr << "ERROR: Current version of flowPsi not compiled with libm3l and lsidpx support" << endl ;
      cerr << "componentMotion: external not supported" << endl ;
      cerr << "Exiting ...  " << endl ;
    }
    exit(-1) ;
  };

}

#endif




