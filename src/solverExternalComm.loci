//#############################################################################
//#
//# Copyright 2018, Adam Jirasek
//#
//# This file is part of the flowPsi computational fluid dynamics solver.
//#
//# The flowPsi solver is free software: you can redistribute it and/or modify
//# it under the terms of the GNU General Public License as published by
//# the Free Software Foundation, either version 3 of the License, or
//# (at your option) any later version.
//#
//# The flowPsi solver is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# GNU General Public License for more details.
//#
//# You should have received a copy of the GNU General Public License
//# along with the flowPsi solver.  If not, see <http://www.gnu.org/licenses>
//#
//#############################################################################



/*
 * 
 * Description: calls functions acting as a bridge between FlowPsi and externally driven processes
 *     For this purpose, it uses two external libraries, libm3l and lsipdx
 *     for more details go to www.github.com/libm3l/libm3l and www.github.com/libm3l/lsipdx 
 *     values of angles, rotation center and translation
 *
 * CHANGELOG:
 * Version   Author:               Date       Patch number  CLA     Comment
 * -------   -------               --------   --------      ---     -------
 * 1-beta-6  Adam Jirasek         2018-03-21                        Initial Implementation
 *
 *
 *
 * 
 */

#include <Loci.h>
#include <stdio.h>
$include "flowPsi.lh"

#include "gridComponent.h"
#include "extcomm_def.h"
#include "src_bridges_types.h"

#include <vector>
#include <list>

using std::list ;
using std::vector ;
using std::endl ;
using std::cerr ;
using std::cout ;
using Loci::MPI_rank ;

#ifdef LIBM3LSIPDX
/*
 * compile with libm3l and lsipdx support
 */
/*
 *  include header files for libm3l and lsipdx library and header file for bridges (located in ../src_bridges)
 */
#include "src_bridges.h"
#include "libm3l.h"
#include "lsipdx.h"

/* 
 * check gridComponent.loci for other smilarities
 */
$type boundaryName(X) param<string>  ;
$type extInterfaceName(X) param<string>  ;

namespace flowPsi { 

  bool ident_intf(string Vol_tag, Loci::options_list ext_interfaces, comm_struct_t *pcomm_str);

  $rule optional(ext_interfaces) {}

 // provides the condition under which to communicate

  $rule default(comm_freq) {
    $comm_freq = 1 ;
  }

  $type do_communicate_nit param<bool> ;
  $rule singleton(do_communicate_nit{n,it}<-ncycle{n},comm_freq,$it{n,it}) {
    //the condition for when to communicate
    if($comm_freq < 0){
        $do_communicate_nit{n,it} = ($$it{n,it} % -$comm_freq) == 0;
    }
    else{
        $do_communicate_nit{n,it} = ($ncycle{n} % $comm_freq) == 0 && ($$it{n,it} == 0) ;
    }
  } 
/*
 * this is test rule which set some motion component parameters
 */
 $type componentName_X blackbox<string> ;
/*
 * vales of the componentName_X which is the same as volumeTag,
 * and is with the componentExternal_X which indicates the tag communicates 
 * externally set in gridComponent.loci
 */
 $rule singleton(XmotionData(X)<-dtmax,stime,ext_interfaces,componentName_X), 
   constraint(componentExternal_X),parametric(volumeTag(X)){

    vect3d cg = vect3d (1.0,1.0,1.0) ;
    vect3d cg_new;
    real t = $stime + $dtmax ;
    string Vol_tag = $componentName_X;
    string commtype;

    lmdouble_t RotCX, RotCY,  RotCZ;
    lmdouble_t TransX, TransY, TransZ;
    lmdouble_t Alpha, Qx, Qy, Qz;
    lmdouble_t ForceX, ForceY, ForceZ;

    comm_struct_t comm_str, *pcomm_str;
    pcomm_str = &comm_str;

    int communicate;

    communicate = 0;

    if(Loci::MPI_rank==0) {
/*
 * communicate
 */
      if( ident_intf(Vol_tag, $ext_interfaces, pcomm_str)){
        communicate = 1;
        commtype = pcomm_str->type;
/*
 * depending on what type of interface we call different routines
 */
        if(commtype.compare("prescribed_quaternion") == 0){
/*
 * interface for prescribing rigid mesh motion through prescribing 
 * quaternion. The bridge enables sending Forces to external solver and 
 * get back quaternion,translation and rotation center
 */
           bridge_prescribed_quaternion(t, ForceX, ForceY, ForceZ, &Alpha, &Qx, &Qy, &Qz,
                  &TransX, &TransY, &TransZ, &RotCX, &RotCY, &RotCZ, pcomm_str);
/*
 * broadcast and save in XmotionData structure
 */
           MPI_Bcast(&communicate,1,MPI_INTEGER,0,MPI_COMM_WORLD) ;

           if(communicate == 1){
             MPI_Bcast(&TransX,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
             MPI_Bcast(&TransY,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
             MPI_Bcast(&TransZ,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
             MPI_Bcast(&RotCX,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
             MPI_Bcast(&RotCY,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
             MPI_Bcast(&RotCZ,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
             MPI_Bcast(&Alpha,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
             MPI_Bcast(&Qx,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
             MPI_Bcast(&Qy,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
             MPI_Bcast(&Qz,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;

             cg     = vect3d(RotCX, RotCY, RotCZ);
             cg_new = vect3d(TransX, TransY, TransZ);
             cg_new = cg + cg_new;

             $XmotionData(X).cg = cg;
             $XmotionData(X).new_cg = cg_new ;
             $XmotionData(X).q.x = Qx ;
             $XmotionData(X).q.y = Qy ;
             $XmotionData(X).q.z = Qz ;
             $XmotionData(X).q.w = Alpha;
           }  
        }else{
            std::cerr << "ERROR: did not find communication type - " << commtype  << " - , check settings in .vars file" << std::endl ;
  //          exit(-1) ;
        }
      }
    } 
  };

/*
 * function loops over interfaces, find if there is associated tag 
 */
     bool ident_intf(string Vol_tag, Loci::options_list ext_interfaces, comm_struct_t *pcomm_str){
/*
 * get pointer on interfaces in facts 
 */
      param<options_list> int_info ;
      int_info = ext_interfaces;

      options_list::option_namelist nl = int_info->getOptionNameList() ;
      options_list::option_namelist::iterator li;
      
      const lmchar_t *cp;
      lmsize_t clen;
/*
 * set li to the beginning of list of interfaces
 */
      li = nl.begin();
      string bname; 
/*
 * set li to the beginning of interface list
 */
      for(li=nl.begin();li!=nl.end();++li) {

        bname = *li ;

        Loci::option_value_type vt = int_info->getOptionValueType(bname);
        Loci::option_values ov = int_info->getOption(bname) ;
        options_list::arg_list value_list ;
        string name ;
/*
 * get options in intf
 */
      param<options_list> bc_info;
      switch(vt) {
      case Loci::NAME :
        ov.get_value(name) ;
        bc_info->setOption(bname,name) ;
        break ;
      case Loci::FUNCTION:
        ov.get_value(name) ;
        ov.get_value(value_list) ;
        bc_info->setOption(bname,name,value_list) ;
        break ;
      default:
        cerr << "setup_interface can not interpret value assigned to " << bname 
             << " in ext_interfaces" << endl ;
        exit(-1) ;
      }
/*
 * parse options
 */
      options_list ol ;
      ol.Input(value_list) ;
/*
 * at the moment bcv is going to be intfr_local or intrf_global
 */
      Loci::variable bcv(name) ;
/*
 * loop through options and add them to bvars
 */
      options_list::option_namelist nlb = ol.getOptionNameList() ;
      Loci::variableSet bvars ;
      Loci::option_values oss;

      double param;
      string type,tag,I_channel, O_channel, intf_name,IP, BCs, I_channel_name, O_channel_name;

      options_list::option_namelist::iterator lii;
      for(lii=nlb.begin();lii!=nlb.end();++lii){

        bvars += Loci::variable(*lii) ;

        if( *lii == "boundary_conditions" ){
            oss = ol.getOption(*lii) ;
            ol.getOption(*lii,BCs);
        }
        else if(*lii == "I_channel" ){
            bzero(pcomm_str->I_channel,80);
            ol.getOption(*lii,I_channel_name) ;
            cp =  I_channel_name.c_str();
            clen = strlen(cp);
            strncpy(pcomm_str->I_channel, cp, clen);
            pcomm_str->I_channel[clen] = '\0';
        }
        else if(*lii == "O_channel" ){
            bzero(pcomm_str->O_channel,80);
	        ol.getOption(*lii,O_channel_name) ;
            cp =  O_channel_name.c_str();
            clen = strlen(cp);
            strncpy(pcomm_str->O_channel, cp, clen);
            pcomm_str->O_channel[clen] = '\0';
        }
        else if(*lii == "tag" ){
	    ol.getOption(*lii,tag) ;
            pcomm_str->tag = tag.c_str();
            if((Vol_tag.compare(tag) && Vol_tag.compare("All")) != 0){
/*
 * if tag different from tag specfied in interface specification or 
 * if tag in interface not All, skip
 */
                goto end_loop;
            }
        }
        else if(*lii == "name" ){
	        ol.getOption(*lii,intf_name) ;
            pcomm_str->intf_name = intf_name.c_str();
        }
        else if(*lii == "type" ){
            bzero(pcomm_str->type,80);
            ol.getOption(*lii,type) ;
            cp =  type.c_str();
            clen = strlen(cp);
            strncpy(pcomm_str->type, cp, clen);
            pcomm_str->type[clen] = '\0';
        }
        else if(*lii == "IP" ){
            bzero(pcomm_str->IP,80);
            ol.getOption(*lii,IP) ;
            cp =  IP.c_str();
            clen = strlen(cp);
            strncpy(pcomm_str->IP, cp, clen);
            pcomm_str->IP[clen] = '\0';         
        }
      }
/*
 * get value of comm_freq from interface
 */
      ol.getOptionUnits("comm_freq","",param);
      pcomm_str->comm_freq = (int)param;
/*
 * get port number
 */
      ol.getOptionUnits("portno","",param);
      pcomm_str->portno = (int)param;

      return true;

end_loop: continue;
      return false;
  }
};
/*
 * list boundary conditions - test rule
 */
//$rule singleton(OUTPUT<-ncycle,boundaryName(X)),
//    constraint(boundaryName(X)),
//    parametric(boundaryName(X))
//    {
///*
// * get number of points on boundary
// */
//        Loci::entitySet dom = entitySet(seq) ;
//        int ndom = dom.size() ;
//        cout << "RANK " << Loci::MPI_rank << " Cycle " << $ncycle << "  " << " BC NAME  is "<<  $boundaryName(X) << "  " << ndom << endl;
//    };

/*
 * list interfaces - test rule
 */
$rule singleton(OUTPUT<-ncycle,extInterfaceName(X)),
    parametric(extInterfaceName(X))
    {
/*
 * get number of points on boundary
 */
        cout << "RANK " << Loci::MPI_rank << " Cycle " << $ncycle << "  " << " INTF NAME  is "<<  $extInterfaceName(X) << endl;
    };
}

#else
/*
 * in case of not having libm3l and lsipdx 
 */
namespace flowPsi { 

  $rule default(comm_freq) {
    $comm_freq = 1 ;
  }

  $rule singleton(XmotionData(X)<-dtmax,stime), 
    constraint(componentExternal_X),parametric(volumeTag(X)){
    if(Loci::MPI_rank==0) {
      cerr << " " << endl ;
      cerr << "ERROR: Current version of flowPsi not compiled with libm3l and lsidpx support" << endl ;
      cerr << "componentMotion: external not supported" << endl ;
      cerr << "Exiting ...  " << endl ;
    }
    exit(-1) ;
  };

}

#endif




