//#############################################################################
//#
//# Copyright 2018, Adam Jirasek
//#
//# This file is part of the flowPsi computational fluid dynamics solver.
//#
//# The flowPsi solver is free software: you can redistribute it and/or modify
//# it under the terms of the GNU General Public License as published by
//# the Free Software Foundation, either version 3 of the License, or
//# (at your option) any later version.
//#
//# The flowPsi solver is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# GNU General Public License for more details.
//#
//# You should have received a copy of the GNU General Public License
//# along with the flowPsi solver.  If not, see <http://www.gnu.org/licenses>
//#
//#############################################################################



/*
 * 
 * Description: calls functions acting as a bridge between FlowPsi and externally driven processes
 *     For this purpose, it uses two external libraries, libm3l and lsipdx
 *     for more details go to www.github.com/libm3l/libm3l and www.github.com/libm3l/lsipdx 
 *     values of angles, rotation center and translation
 *
 * CHANGELOG:
 * Version   Author:               Date       Patch number  CLA     Comment
 * -------   -------               --------   --------      ---     -------
 * 1-beta-6  Adam Jirasek         2018-03-21                        Initial Implementation
 *
 *
 *
 * 
 */

#include <Loci.h>
#include <stdio.h>
$include "flowPsi.lh"

#include "gridComponent.h"
#include "extcomm_def.h"
#include "src_bridges_types.h"
#include "solverExternalComm.h"

#include <vector>
#include <list>
#include <string.h>
#include <map>
using std::map ;

using std::list ;
using std::vector ;
using std::endl ;
using std::cerr ;
using std::cout ;
using Loci::MPI_rank ;

#ifdef LIBM3LSIPDX
/*
 * compile with libm3l and lsipdx support
 *
 *  include header files for libm3l and lsipdx library and header file for bridges (located in ../src_bridges)
 */
#include "src_bridges.h"
#include "libm3l.h"
#include "lsipdx.h"
/* 
 * declarations
 */
$type extInterfaceName(X,Y) param<string>;
$type ConstextInterfaceName(X,Y) constraint;
$type extInterfaceNameStr(X,Y)  param<InterfStr_t>;
$type componentName_X blackbox<string> ;
// $type localvec store<Loci::vector3d > ;

$type localvec store<Loci::vector3d<Loci::real_t> > ;


namespace flowPsi { 

 // $type intf param<int>;

   bool ident_intf(Loci::options_list::arg_list *pVol_tags, Loci::options_list ext_interfaces, 
                      comm_struct_t *pcomm_str, string name, string type);
  $rule optional(ext_interfaces) {}
/*
 * componentExternal is set always when interface calls for external communication
 * it is set in gridComponents.loci
 */
  $type $componentExternalRigid_X Constraint ;
  
 $type componentName_X blackbox<string> ;
/*
 * values of the componentName_X which is the same as volumeTag,
 * and is with the $componentExternalRigid_X which indicates the tag communicates 
 * externally set in gridComponent.loci
 */

/*
 * this is a temporary hack which makes the comm rule always executed
 * find out how to replace by conditional($extInterfaceNameStr(X).INTF_docommunicate)
 */
  $type docom param<bool>;
  $rule default(docom){
      $docom=true;
  }

  $type docomappl param<bool>;
  $rule default(docomappl){
      $docomappl=false;
  }
/*
 * execute interfaces
 *
 * Prescribed Quaternion interface
 */
//     $rule singleton(OUTPUT<-ncycle,volumeTag(X),
//     extInterfaceNameStr(X,Y),extInterfaceName(X,Y),ext_interfaces),
//     constraint(ConstextInterfaceName(X,Y),volumeTag(X)),conditional(docom),
//     parametric(extInterfaceNameStr(X,Y)){
//     
//        if( $extInterfaceNameStr(X,Y).INTF_docommunicate){
//            std::cout << "COMM1111111111111111  - " << $extInterfaceName(X,Y)  << "    " << ($extInterfaceNameStr(X,Y)).INTF_docommunicate<<  " Volume tag: " << $volumeTag(X) <<  ::endl ;
//        }
//   }

  $type docommnit param<bool> ;
  $type docomm{n,it} param<bool> ;

  
  $rule singleton(docomm{n,it}<-ncycle{n},print_freq,$it{n,it}) {
    //the condition for dumping out cfl information
    // print out cfl when we are dumping an output file (ncyc % print_freq) == 0
    // and we are on the first newton iteration
    $docomm{n,it} = ($ncycle{n} % 1) == 0 && ($$it{n,it} %1) ;
          std::cout << " In doooooooooooooooooooooooooooo     - " << $docomm{n,it} <<std::endl ;

  }

/*
 * rigid body motion interface
 */
   $rule apply(componentMotionData<-ncycle, stime, dtmax,ext_interfaces,extInterfaceNameStr(X,Y),
                 componentName_X,extInterfaceName(X,Y),volumeTag(X))[Loci::NullOp], 
                 parametric(extInterfaceName(X,Y)),
                 constraint(ConstextInterfaceName(X,Y),volumeTag(X),componentExternalRigid_X), 
                 conditional(docom),
                 prelude{
/*
 * if interface is "active" communicate
 */
    if(Loci::MPI_rank==0) 
      std::cout << "COAPLYYYYYYYYYYYYY  - " << $extInterfaceName(X,Y)  << "    " << $volumeTag(X) <<  "  BOOL:  " << (*$extInterfaceNameStr(X,Y)).INTF_docommunicate << "   NCYCLE: " << *$ncycle   << std::endl ;
      
      
      int len = (*$extInterfaceNameStr(X,Y)).INTF_domsize;
      
//       for(int i=0; i < len;i++){
//                 std::cout << "COOOOOOOOORDS  " << $localvec[i] << "    " << std::endl ;
//       }
/*
 * loop over fact database with interfaces and find if it is there
 */
      comm_struct_t comm_str, *pcomm_str;
      pcomm_str = &comm_str;

      int comm_interface;
      comm_interface = 0;
/*
 * set defaults
 */      
//       (*$extInterfaceNameStr(X,Y)).INTF_docommunicate = false;
      string commtype;
      Loci::options_list::arg_list Vol_tags, *pVol_tags;
      pVol_tags = &Vol_tags;

      if(Loci::MPI_rank==0) {
        std::cout << "Looking for interface  - " <<  *$extInterfaceName(X,Y)  << std::endl ; 
/*
 * identify interface
 */
        if( ident_intf(pVol_tags, *$ext_interfaces, pcomm_str, *$extInterfaceName(X,Y), "prescribed_quaternion")){
/*
 * check that type among allowed types of interfaces
 */
          lmsize_t clen = strlen(pcomm_str->type);
          if( strncmp(pcomm_str->type, "prescribed_quaternion", clen) != 0 &&
              strncmp(pcomm_str->type, "test_interface", clen) != 0 ){

            std::cerr << "ERROR: uknown type of interface '" << pcomm_str->type << "', check settings in .vars file" << std::endl ;
            exit(-1) ;

          }
/*
 * set if to communicate
 */
//           if(pcomm_str->comm_freq < 0){
//             if(  (*$$it % pcomm_str->comm_freq) == 0 )comm_interface = 1;
//           }
//           else{
//             if ( (*$ncycle % pcomm_str->comm_freq) == 0 && (*$$it == 0) )  comm_interface = 1;;
//           }
        }
        else{
            std::cerr << "ERROR: did not find interface - " << *$extInterfaceName(X,Y)  << " - , check settings in .vars file" << std::endl ;
            exit(-1) ;
        }
       }
/* 
 * broadcast comm_interface
 */
        MPI_Bcast(&comm_interface,1,MPI_INTEGER,0,MPI_COMM_WORLD) ;
        if(comm_interface == 1){
/*
 * if comm_interface == 1 broadcast pcomm_str
 */
           MPI_Bcast(pcomm_str->type,80,MPI_CHAR,0,MPI_COMM_WORLD) ;
           commtype = pcomm_str->type;

            if(Loci::MPI_rank==0)   std::cout << "communication  - " << commtype  << " and char " << pcomm_str->type << endl ;

           if(commtype.compare("prescribed_quaternion") == 0){
    //           $extInterfaceNameStr(X,Y).INTF_docommunicate = true;
           } 
           else if(commtype.compare("test_interface") == 0 ){
     //          $extInterfaceNameStr(X,Y).INTF_docommunicate = true;
           }
           else{
              std::cerr << "ERROR: did not find communication type - " << commtype  << " - , check settings in .vars file" << std::endl ;
              exit(-1) ;
           }

        }


  //    if( (*$extInterfaceNameStr(X,Y)).INTF_docommunicate){    

        vect3d cg = vect3d (1.0,1.0,1.0) ;
        vect3d cg_new;
/*
 * get simulation time
 */
        real t = *$stime + *$dtmax ;

        lmdouble_t RotCX, RotCY,  RotCZ;
        lmdouble_t TransX, TransY, TransZ;
        lmdouble_t Alpha, Qx, Qy, Qz;
        lmdouble_t ForceX, ForceY, ForceZ;

        Loci::options_list::arg_list list ;
        options_list::arg_list value_list ;
        componentXform xform ;

        if(Loci::MPI_rank==0) {
/*
 * communicate, if interface found, execute it, all checks were done before this rule
 */
           if(ident_intf(pVol_tags, *$ext_interfaces, pcomm_str,*$extInterfaceName(X,Y), "prescribed_quaternion")){
/*
 * this is rigid body motion interface, sends away forces and gets back quaternion, translation and 
 * center of rotation
 */
               bridge_prescribed_quaternion(t, ForceX, ForceY, ForceZ, &Alpha, &Qx, &Qy, &Qz,
                   &TransX, &TransY, &TransZ, &RotCX, &RotCY, &RotCZ, pcomm_str);
            }
        }
/*
 * broadcast and save in XmotionData structure
 */
        MPI_Bcast(&TransX,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&TransY,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&TransZ,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&RotCX,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&RotCY,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&RotCZ,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&Alpha,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&Qx,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&Qy,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&Qz,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;

        cg     = vect3d(RotCX, RotCY, RotCZ);
        cg_new = vect3d(TransX, TransY, TransZ);
        cg_new = cg + cg_new;

        xform.cg = cg;
        xform.new_cg = cg_new ;
        xform.q.x = Qx ;
        xform.q.y = Qy ;
        xform.q.z = Qz ;
        xform.q.w = Alpha;
/*
 * loop over volume tags and set componentMotionData
 */
        int size = Vol_tags.size() ;
        string name, name1;
/*
 * loop over volume tags
 */
       options_list ol ;
       ol.Input(Vol_tags);
       options_list::option_namelist nlb = ol.getOptionNameList() ; 
       options_list::option_namelist::iterator lii;
//       
//          for(lii=nlb.begin();lii!=nlb.end();++lii){ 
//            name1 = *lii;
           name = *$componentName_X;
            std::cout << "TAGGGGGGGGGGGGG  - " << Loci::MPI_rank << "   " << "'"<<name1<<"    "<< name << " SIZE " << (*$extInterfaceNameStr(X,Y)).INTF_domsize<<std::endl ;
          (*$componentMotionData)[name] = xform;
//         }  
    //  }
   };
   
   
    $rule pointwise(localvec<-ncycle,facecenter),
     constraint(ConstextInterfaceName(X,Y)),parametric(extInterfaceName(X,Y))
     {
/*
 * get number of points on boundaries in interface
 */         
         std::cout << "asigning        - " << Loci::MPI_rank << "   " << std::endl ;

        $localvec = $facecenter;
        };
   
//    $rule pointwise(OUTPUT<-ncycle,temperature_f, u_f,facecenter),
//     constraint(ConstextInterfaceName(X,Y)),parametric(extInterfaceName(X,Y))
//     {
// /*
//  * get number of points on boundaries in interface
//  */
//      cout << "RANK " << Loci::MPI_rank << " Cycle " << " INTF is "<<   $ncycle << "  " <<  $temperature_f << "  " << $facecenter<< endl;
//     };

}


#else
/*
 * in case of not having libm3l and lsipdx 
 */
namespace flowPsi { 


  $rule singleton(XmotionData(X)<-dtmax,stime), 
    constraint($componentExternalRigid_X),parametric(volumeTag(X)){
    if(Loci::MPI_rank==0) {
      cerr << " " << endl ;
      cerr << "ERROR: Current version of flowPsi not compiled with libm3l and lsidpx support" << endl ;
      cerr << "componentMotion: external not supported" << endl ;
      cerr << "Exiting ...  " << endl ;
    }
    exit(-1) ;
  };

}

#endif




