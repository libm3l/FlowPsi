//#############################################################################
//#
//# Copyright 2018, Adam Jirasek
//#
//# This file is part of the flowPsi computational fluid dynamics solver.
//#
//# The flowPsi solver is free software: you can redistribute it and/or modify
//# it under the terms of the GNU General Public License as published by
//# the Free Software Foundation, either version 3 of the License, or
//# (at your option) any later version.
//#
//# The flowPsi solver is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# GNU General Public License for more details.
//#
//# You should have received a copy of the GNU General Public License
//# along with the flowPsi solver.  If not, see <http://www.gnu.org/licenses>
//#
//#############################################################################



/*
 * 
 * Description: calls functions acting as a bridge between FlowPsi and externally driven processes
 *     For this purpose, it uses two external libraries, libm3l and lsipdx
 *     for more details go to www.github.com/libm3l/libm3l and www.github.com/libm3l/lsipdx 
 *     values of angles, rotation center and translation
 *
 * CHANGELOG:
 * Version   Author:               Date       Patch number  CLA     Comment
 * -------   -------               --------   --------      ---     -------
 * 1-beta-6  Adam Jirasek         2018-03-21                        Initial Implementation
 *
 *
 *
 * 
 */
#include "libm3l.h"
#include "lsipdx.h"

#include <Loci.h>
#include <stdio.h>
$include "flowPsi.lh"

#include "gridComponent.h"
#include "extcomm_def.h"
#include "src_bridges_types.h"
#include "solverExternalComm.h"

#include <vector>
#include <list>
#include <string.h>
#include <map>
using std::map ;

using std::list ;
using std::vector ;
using std::endl ;
using std::cerr ;
using std::cout ;
using Loci::MPI_rank ;

#ifdef LIBM3LSIPDX
/*
 * compile with libm3l and lsipdx support
 *
 *  include header files for libm3l and lsipdx library and header file for bridges (located in ../src_bridges)
 */
#include "src_bridges.h"
#include "libm3l.h"
#include "lsipdx.h"
/* 
 * declarations
 */
$type extInterfaceName(X,Y) param<string>;
$type ConstextInterfaceName(X,Y) constraint;
$type extInterfaceNameStr(X,Y)  param<InterfStr_t>;
$type componentName_X blackbox<string> ;


$type componentExternalRigid_X_Y Constraint ;
$type componentExternalElastic_X_Y Constraint ;
$type componentExternalRigidElastic_X_Y Constraint;
$type componentExternalMotion_X_Y Constraint ;
$type componenLsipdxExtMotion Constraint ;

$type volumeTag(X) param<string> ;
$type localvec store<Loci::vector3d<Loci::real_t> > ;

$type nodeDisp_b                        store<vect3d>; 
$type nodeDisp_bc                      store<vect3d>; 

// $type faked_time param<flowPsi::real> ; 

node_t *Gnode;

namespace flowPsi { 

   bool ident_intf(Loci::options_list::arg_list *pVol_tags, Loci::options_list ext_interfaces, 
                      comm_struct_t *pcomm_str, string name, string type);
      
   $rule optional(ext_interfaces) {}
/*
 * these are gather and scatter routines s
 */
void  GatherDVec(lmdouble_t *gv, lmdouble_t *v, int len, MPI_Comm comm) {
	int procs = 1 ;
        if(len < 1)len = 0;
        if(comm == MPI_COMM_NULL)return;
	MPI_Comm_size(comm,&procs) ;
/*
 * gather sizes of vectors on root partition
 */
	std::vector<int> part_sizes(procs) ;
	MPI_Gather(&len,1,MPI_INT, &part_sizes[0],1,MPI_INT,0,comm) ;
/*
 * get vector of displacements
 */
	std::vector<int> displs(procs) ;
        
	displs[0] = 0 ;
	for(int i=1;i<procs;++i)
		displs[i] = displs[i-1]+part_sizes[i-1];
/*
 * gather data
 */
	MPI_Gatherv(&v[0],len,MPI_DOUBLE,&gv[0],&part_sizes[0],&displs[0],MPI_DOUBLE,
			0, comm) ;
}

void  ScatterDVec(lmdouble_t *gv, lmdouble_t *v, int len, MPI_Comm comm) {
	int procs = 1 ;
	MPI_Comm_size(comm,&procs) ;
/*
 * gather sizes of vectors on root partition
 */
	std::vector<int> part_sizes(procs) ;
	MPI_Gather(&len,1,MPI_INT, &part_sizes[0],1,MPI_INT,0,comm) ;
/*
 * get vector of displacements
 */
	std::vector<int> displs(procs) ;
        
	displs[0] = 0 ;
	for(int i=1;i<procs;++i)
		displs[i] = displs[i-1]+part_sizes[i-1];
/*
 * scatter data
 */
	MPI_Scatterv(&gv[0],&part_sizes[0],&displs[0],MPI_DOUBLE,
			&v[0],len,MPI_DOUBLE,0, comm) ;
}
  
//   $type InterfaceIO  blackbox<int>; 
/*
 * count number of elements 
 */
//   $rule unit(InterfaceIO <- face2node, volumeTag(X), extInterfaceName(X,Y) ),
// 	option(disable_threading),constraint( ConstextInterfaceName(X,Y),volumeTag(X)),parametric(extInterfaceName(X,Y)),
//     prelude {  
//      
//          node_t *Pelems=NULL, *TmpNode=NULL, *IntfNode=NULL;
//          lmsize_t dim[1];
//          find_t *Founds=NULL;
//          lmchar_t buffer[80];
//          Loci::storeRepP sp;
//          Loci::fact_db* facts = Loci::exec_current_fact_db ;
// 
//          string str_intfname =  *$extInterfaceName(X,Y) ;
//          string str_voltagname =  *$volumeTag(X) ;
//         
//          if(Loci::MPI_rank==0)
//           std::cout << "Adding element info to Interface "<<  str_intfname <<endl ;        
//          
//          string IntfName = "LocConstextInterfaceName("+str_voltagname+","+str_intfname+")"; 
//          Loci::fact_db::distribute_infoP df = 0;         
//          if(facts->is_distributed_start())
// 	       df = facts->get_distribute_info();
// 
//          sp = facts->get_variable(IntfName) ;
//          Loci::entitySet dom = entitySet(sp->domain()) ;
//          
//          if(df!=0) {
// 	       dom &= df->my_entities ;
//          }
// 
//          int ntrias = 0 ;
// 	     int nquads = 0 ;
//          FORALL(dom, ii) {
// 		    if ($face2node[ii].size() == 3)
// 		      ntrias++ ;
// 		    else if ($face2node[ii].size() == 4)
// 			   nquads++ ;
// 	      } ENDFORALL ;
// /*
//  * find interface with file Name with name *$extInterfaceName(X,Y) in it
//  */
//          const char *srt = str_intfname.c_str(); 
//          sprintf (buffer, "/*/SV_Name=%s", srt);
// /*
//  * locate interface, clean allocated memory
//  */      
//         if( (Founds = m3l_Locate(Gnode, "/Interfaces/Interface", buffer,  (lmchar_t *)NULL)) != NULL){
//           
//           IntfNode = m3l_get_Found_node(Founds, 0);
//           m3l_DestroyFound(&Founds);
// 
//         }
//         else{
//           Perror("Did not find aeroleastic interface");
//         }
//         
//         if(  (Pelems = m3l_Mklist("Element_info", "DIR", 0, 0, &IntfNode, "/Interface", "./", (char *)NULL)) == 0)
// 		    Perror("m3l_Mklist");
//           
//         dim[0] = 1;
//         if(  (TmpNode = m3l_Mklist("Tria", "ST", 1, dim, &Pelems, "./Element_info", "./", (char *)NULL)) == 0)
// 		  Error("socket_FlowPsi2simulink: m3l_Mklist");
//         TmpNode->data.st[0] = ntrias;
//           if(  (TmpNode = m3l_Mklist("Quad", "ST", 1, dim, &Pelems, "./Element_info", "./", (char *)NULL)) == 0)
// 		Error("socket_FlowPsi2simulink: m3l_Mklist");
//            TmpNode->data.st[0] = nquads;        
//         
//     };
/*
 * 
 * componentExternal is set always when interface calls for external communication
 * it is set in gridComponents.loci
 */  
 $type componentName_X blackbox<string> ;
/*
 * values of the componentName_X which is the same as volumeTag,
 * and is with the $componentExternalRigid_X which indicates the tag communicates 
 * externally set in gridComponent.loci
 */
  
//    $rule default(componentExternalRigid_X_Y,componentExternalElastic_X_Y,
//        componentExternalMotion_X_Y,componentExternalRigidElastic_X_Y, componenLsipdxExtMotion),
//        parametric(extInterfaceName(X,Y)){
//            
//        std::cout << "Set default component flag - " << std::endl ; 
// 
//        
//        $componentExternalRigid_X_Y = EMPTY ;
//        $componentExternalRigidElastic_X_Y = EMPTY ;
//        $componentExternalElastic_X_Y = EMPTY ;
//        $componentExternalMotion_X_Y = EMPTY ;
//        $componenLsipdxExtMotion = EMPTY;
//   }

  $rule constraint(componentExternalRigid_X_Y,componentExternalElastic_X_Y,
       componentExternalMotion_X_Y,componentExternalRigidElastic_X_Y, componenLsipdxExtMotion<-
       extInterfaceName(X,Y),ext_interfaces), parametric(extInterfaceName(X,Y)), 
       constraint(ConstextInterfaceName(X,Y)) {

       Loci::options_list::arg_list Vol_tags, *pVol_tags;
       pVol_tags = &Vol_tags;
       comm_struct_t comm_str, *pcomm_str;
       pcomm_str = &comm_str;
       
        $componentExternalRigid_X_Y = EMPTY ;
        $componentExternalRigidElastic_X_Y = EMPTY ;
        $componentExternalElastic_X_Y = EMPTY ;
        $componentExternalMotion_X_Y = EMPTY ;
        $componenLsipdxExtMotion = EMPTY;

         if(Loci::MPI_rank==0)  std::cout << "Looking for interface to set component flag - " <<  $extInterfaceName(X,Y)  << std::endl ; 
/*
 * identify interface
 */
        if( ident_intf(pVol_tags, $ext_interfaces, pcomm_str, $extInterfaceName(X,Y), "prescribed_quaternion")){
            
             if(Loci::MPI_rank==0)  std::cout << "Interface is set to prescribed_quaternion " << std::endl ; 
            
            $componentExternalRigid_X_Y = ~EMPTY;
            $componenLsipdxExtMotion      = ~EMPTY;
        }
        else if( ident_intf(pVol_tags, $ext_interfaces, pcomm_str, $extInterfaceName(X,Y), "aeroelasticity")){
       
             if(Loci::MPI_rank==0)  std::cout << "Interface is set to aeroelasticity " << std::endl ;             
            
            $componentExternalElastic_X_Y = ~EMPTY;
            $componenLsipdxExtMotion        = ~EMPTY;
        }
        else if( ident_intf(pVol_tags, $ext_interfaces, pcomm_str, $extInterfaceName(X,Y), "aeroelasticity_rigid")){

             if(Loci::MPI_rank==0)  std::cout << "Interface is set to aeroelasticity_rigid " << std::endl ; 

            $componentExternalRigidElastic_X_Y = ~EMPTY;
            $componenLsipdxExtMotion                = ~EMPTY;
        }
        else
        {
            if(Loci::MPI_rank==0)  std::cerr << "ERROR: unknown type of interface (C1) '" << pcomm_str->type << "', check settings in .vars file" << std::endl ;
           exit(-1) ;
        }
  }

/*
 * this is a temporary hack which makes the comm rule always executed
 * find out how to replace by conditional($extInterfaceNameStr(X).INTF_docommunicate)
 */
  $type docom param<bool>;
  $rule default(docom){
      $docom=true;
  }
/*
 * execute interfaces
 *
 * Prescribed Quaternion interface
 */
  $type docomm param<bool> ;

  
  $rule singleton(docomm{n,it}<-ncycle{n},print_freq,$it{n,it}) {
    //the condition for dumping out cfl information
    // print out cfl when we are dumping an output file (ncyc % print_freq) == 0
    // and we are on the first newton iteration
    $docomm{n,it} = ($ncycle{n} % 1) == 0 && ($$it{n,it} %1) ;
          std::cout << " In doooooooooooooooooooooooooooo     - " << $docomm{n,it} <<std::endl ;

  }
  
  
/*
 * rigid body motion interface
 */
   $rule apply(componentMotionData<-ncycle, stime, dtmax,ext_interfaces,extInterfaceNameStr(X,Y),
                 componentName_X,extInterfaceName(X,Y),volumeTag(X))[Loci::NullOp], 
                 parametric(extInterfaceName(X,Y)),
                 constraint(ConstextInterfaceName(X,Y),volumeTag(X),componentExternalRigid_X_Y), 
                 conditional(docom),
                 prelude{
/*
 * if interface is "active" communicate
 */
      if(Loci::MPI_rank==0) 
         m3l_Cat(Gnode, "--detailed", "-L", "-P", "*",   (lmchar_t *)NULL);
/*
 * loop over fact database with interfaces and find if it is there
 */
      comm_struct_t comm_str, *pcomm_str;
      pcomm_str = &comm_str;

      int comm_interface;
      comm_interface = 0;
/*
 * set defaults
 */      
//       (*$extInterfaceNameStr(X,Y)).INTF_docommunicate = false;
      string commtype;
      Loci::options_list::arg_list Vol_tags, *pVol_tags;
      pVol_tags = &Vol_tags;

      if(Loci::MPI_rank==0) {
        std::cout << "Looking for interface  - " <<  *$extInterfaceName(X,Y)  << std::endl ; 
/*
 * identify interface
 */
        if( ident_intf(pVol_tags, *$ext_interfaces, pcomm_str, *$extInterfaceName(X,Y), "prescribed_quaternion")){
/*
 * check that type among allowed types of interfaces
 */
          lmsize_t clen = strlen(pcomm_str->type);
          if( strncmp(pcomm_str->type, "prescribed_quaternion", clen) != 0 &&
              strncmp(pcomm_str->type, "test_interface", clen) != 0) {

            std::cerr << "ERROR: unknown type of interface (1) '" << pcomm_str->type << "', check settings in .vars file" << std::endl ;
            exit(-1) ;

          }
/*
 * set if to communicate
 */
//           if(pcomm_str->comm_freq < 0){
//             if(  (*$$it % pcomm_str->comm_freq) == 0 )comm_interface = 1;
//           }
//           else{
//             if ( (*$ncycle % pcomm_str->comm_freq) == 0 && (*$$it == 0) )  comm_interface = 1;;
//           }
        }
        else{
            std::cerr << "ERROR(1): did not find interface - " << *$extInterfaceName(X,Y)  << " -  check settings in .vars file" << std::endl ;
            exit(-1) ;
        }
       }
/* 
 * broadcast comm_interface
 */
        MPI_Bcast(&comm_interface,1,MPI_INTEGER,0,MPI_COMM_WORLD) ;
        if(comm_interface == 1){
/*
 * if comm_interface == 1 broadcast pcomm_str
 */
           MPI_Bcast(pcomm_str->type,80,MPI_CHAR,0,MPI_COMM_WORLD) ;
           commtype = pcomm_str->type;

            if(Loci::MPI_rank==0)   std::cout << "communication  - " << commtype  << " and char " << pcomm_str->type << endl ;

           if(commtype.compare("prescribed_quaternion") == 0){
    //           $extInterfaceNameStr(X,Y).INTF_docommunicate = true;
           } 
           else if(commtype.compare("test_interface") == 0 ){
     //          $extInterfaceNameStr(X,Y).INTF_docommunicate = true;
           }
           else{
              std::cerr << "ERROR: did not find communication type (2) - " << commtype  << " - , check settings in .vars file" << std::endl ;
              exit(-1) ;
           }

        }

  //    if( (*$extInterfaceNameStr(X,Y)).INTF_docommunicate){    

        vect3d cg = vect3d (1.0,1.0,1.0) ;
        vect3d cg_new;
/*
 * get simulation time
 */
        real t = *$stime + *$dtmax ;

        lmdouble_t RotCX, RotCY,  RotCZ;
        lmdouble_t TransX, TransY, TransZ;
        lmdouble_t Alpha, Qx, Qy, Qz;
        lmdouble_t ForceX, ForceY, ForceZ;

        Loci::options_list::arg_list list ;
        options_list::arg_list value_list ;
        componentXform xform ;

        if(Loci::MPI_rank==0) {
/*
 * communicate, if interface found, execute it, all checks were done before this rule
 */
           if(ident_intf(pVol_tags, *$ext_interfaces, pcomm_str,*$extInterfaceName(X,Y), "prescribed_quaternion")){
/*
 * this is rigid body motion interface, sends away forces and gets back quaternion, translation and 
 * center of rotation
 */
    //           bridge_prescribed_quaternion(t, ForceX, ForceY, ForceZ, &Alpha, &Qx, &Qy, &Qz,
    //               &TransX, &TransY, &TransZ, &RotCX, &RotCY, &RotCZ, pcomm_str);
            }
        }
/*
 * broadcast and save in XmotionData structure
 */
        MPI_Bcast(&TransX,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&TransY,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&TransZ,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&RotCX,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&RotCY,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&RotCZ,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&Alpha,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&Qx,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&Qy,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&Qz,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;

        cg     = vect3d(RotCX, RotCY, RotCZ);
        cg_new = vect3d(TransX, TransY, TransZ);
        cg_new = cg + cg_new;

        xform.cg = cg;
        xform.new_cg = cg_new ;
        xform.q.x = Qx ;
        xform.q.y = Qy ;
        xform.q.z = Qz ;
        xform.q.w = Alpha;
/*
 * loop over volume tags and set componentMotionData
 */
       string name = *$componentName_X;
       (*$componentMotionData)[name] = xform;
   };

    //  $rule apply(OUTPUT<-nodeDisp_b)[Loci::NullOp], 
    //             parametric(extInterfaceName(X,Y)),
    //             constraint(ConstextInterfaceName(X,Y),volumeTag(X),componentExternalElastic_X_Y), 
    //             conditional(docom),
    //             prelude{
    //             }; 
/*
 * elastic body motion interface
 * ====================================================================================
 */

   $rule apply(nodeDisp_b<-ncycle, stime, dtmax,ext_interfaces,extInterfaceNameStr(X,Y),
                 extInterfaceName(X,Y),volumeTag(X),ConstextInterfaceName(X,Y),
                 face2node, pos,facecenter,iflux)[Loci::NullOp], 
                 parametric(extInterfaceName(X,Y)),
                 constraint(ConstextInterfaceName(X,Y),volumeTag(X),componentExternalElastic_X_Y,deformNodes), 
                 conditional(docom),
                 prelude{
/*
 * if interface is "active" communicate
 */
    find_t *Founds=NULL;
    node_t *IntfNode, *Snode, *local_data, *global_data, *FoundNode;
    char buffer [80];
    lmdouble_t *forces, *displacements, *forcesg, *displacementsg; 
    lmdouble_t *g_time, *coords, *coordsg;
    MPI_Comm comm  = MPI_Comm_f2c((*$extInterfaceNameStr(X,Y)).INTF_comm); 
    lmsize_t *dims, *domsize;
    
    double simulation_time, delta_t;
    int time_shift;

    
    if(Loci::MPI_rank==0) 
      std::cout << "COAPLYYYYYYYYYYYYY- AEROELS  - " << $extInterfaceName(X,Y)  << "    " << $volumeTag(X) <<  "  BOOL:  " << (*$extInterfaceNameStr(X,Y)).INTF_docommunicate << "   NCYCLE: " << *$ncycle   << std::endl ;
    
     if(Loci::MPI_rank==0) 
         m3l_Cat(Gnode, "--detailed", "-L", "-P", "*",   (lmchar_t *)NULL);
/*
 * find interface with file Name with name *$extInterfaceName(X,Y) in it
 */
       string str_intfname =  *$extInterfaceName(X,Y) ;
       string str_voltagname =  *$volumeTag(X) ;
       const char *srt = str_intfname.c_str(); 
       sprintf (buffer, "/*/SV_Name=%s", srt);
/*
 * locate interface, clean allocated memory
 */      
      if( (Founds = m3l_Locate(Gnode, "/Interfaces/Interface", buffer,  (lmchar_t *)NULL)) != NULL){
          
          IntfNode = m3l_get_Found_node(Founds, 0);
          m3l_DestroyFound(&Founds);

      }
      else{
          Perror("Did not find aeroleastic interface");
      }
/*
 * loop over fact database with interfaces and find if it is there
 */
      comm_struct_t comm_str, *pcomm_str;
      pcomm_str = &comm_str;

      int comm_interface;
      comm_interface = 1;
      Loci::storeRepP sp;
      Loci::fact_db* facts = Loci::exec_current_fact_db ;     
/*
 * get simulation time
 */
//       real t = *$stime + *$dtmax ;
      string commtype;
      Loci::options_list::arg_list Vol_tags, *pVol_tags;
      pVol_tags = &Vol_tags;
      
      if(Loci::MPI_rank==0) {
        std::cout << "Looking for interface  - " <<  *$extInterfaceName(X,Y)  << std::endl ; 
/*
 * identify interface
 */
        if( ident_intf(pVol_tags, *$ext_interfaces, pcomm_str, *$extInterfaceName(X,Y), "aeroelasticity")){
/*
 * check that type among allowed types of interfaces
 */
          lmsize_t clen = strlen(pcomm_str->type);
          if(strncmp(pcomm_str->type, "aeroelasticity", clen) != 0 ){

            std::cerr << "ERROR: unknown type of interface (3-1) '" << pcomm_str->type << "', check settings in .vars file" << std::endl ;
            exit(-1) ;

          }
        }
        else{
            std::cerr << "ERROR(2): did not find interface - " << *$extInterfaceName(X,Y)  << " - , check settings in .vars file" << std::endl ;
            exit(-1) ;
        }
       }
/* 
 * broadcast comm_interface
 */
        MPI_Bcast(&comm_interface,1,MPI_INTEGER,0,MPI_COMM_WORLD) ;
        if(comm_interface == 1){
/*
 * if comm_interface == 1 broadcast pcomm_str
 */
           MPI_Bcast(pcomm_str->type,80,MPI_CHAR,0,MPI_COMM_WORLD) ;
           commtype = pcomm_str->type;

           if(commtype.compare("aeroelasticity") == 0){
    //           $extInterfaceNameStr(X,Y).INTF_docommunicate = true;
           } 
           else{
              std::cerr << "ERROR: did not find communication type (3-12) - " << commtype  << " - , check settings in .vars file" << std::endl ;
              exit(-1) ;
           }

        }
        
        lmsize_t len = (*$extInterfaceNameStr(X,Y)).INTF_domsize;

        string IntfName = "LocConstextInterfaceName("+str_voltagname+","+str_intfname+")"; 
        Loci::fact_db::distribute_infoP df = 0;         
        if(facts->is_distributed_start())
	      df = facts->get_distribute_info();

        sp = facts->get_variable(IntfName) ;
        Loci::entitySet intsurf = entitySet(sp->domain()) ;
         
        if(df!=0) {
	       intsurf &= df->my_entities ;
        }

/*
 * find vector of local forces and displacements, on the root partition,find 
 * global vectors too. Omit all checks, proper coding would require to so si
 */
        Founds = m3l_Locate(IntfNode, "./Interface/local_data", "/*/*",  (lmchar_t *)NULL);
/*
 */
        local_data = m3l_get_Found_node(Founds, 0);
        m3l_DestroyFound(&Founds);
        
        if(comm != MPI_COMM_NULL && len > 0){
        
            Founds = m3l_Locate(local_data, "./local_data/Forces", "/*/*",  (lmchar_t *)NULL);
/*
 */	
            FoundNode = m3l_get_Found_node(Founds, 0);
            forces =(lmdouble_t *)m3l_get_data_pointer(FoundNode);
            m3l_DestroyFound(&Founds);
        
            Founds = m3l_Locate(local_data, "./local_data/coordinates", "/*/*",  (lmchar_t *)NULL);
/*
 */	
            FoundNode = m3l_get_Found_node(Founds, 0);
            coords =(lmdouble_t *)m3l_get_data_pointer(FoundNode);
            m3l_DestroyFound(&Founds);
            
            Founds = m3l_Locate(local_data, "./local_data/disps", "/*/*",  (lmchar_t *)NULL);
/*
 */	
            FoundNode = m3l_get_Found_node(Founds, 0);
            displacements =(lmdouble_t *)m3l_get_data_pointer(FoundNode);
            m3l_DestroyFound(&Founds);

        }
        
        if(Loci::MPI_rank==0) {
          Founds = m3l_Locate(IntfNode, "./Interface/global_data", "/*/*",  (lmchar_t *)NULL);
/*
 */
          global_data = m3l_get_Found_node(Founds, 0);
          m3l_DestroyFound(&Founds);
        
          Founds = m3l_Locate(global_data, "./global_data/Forces", "/*/*",  (lmchar_t *)NULL);
/*
 */
          FoundNode = m3l_get_Found_node(Founds, 0);
          forcesg =(lmdouble_t *)m3l_get_data_pointer(FoundNode);
          m3l_DestroyFound(&Founds);
          
          Founds = m3l_Locate(global_data, "./global_data/coordinates", "/*/*",  (lmchar_t *)NULL);
/*
 */
          FoundNode = m3l_get_Found_node(Founds, 0);
          coordsg = (lmdouble_t *)m3l_get_data_pointer(FoundNode);
          dims = m3l_get_List_dim(FoundNode);
          m3l_DestroyFound(&Founds);
          
          Founds = m3l_Locate(global_data, "./global_data/disps", "/*/*",  (lmchar_t *)NULL);
/*
 */
          FoundNode = m3l_get_Found_node(Founds, 0);
          displacementsg = (lmdouble_t *)m3l_get_data_pointer(FoundNode);
          dims = m3l_get_List_dim(FoundNode);
          m3l_DestroyFound(&Founds);

          Founds = m3l_Locate(global_data, "./global_data/time", "/*/*",  (lmchar_t *)NULL);
/*
 */
          FoundNode = m3l_get_Found_node(Founds, 0);
          g_time =(lmdouble_t *)m3l_get_data_pointer(FoundNode);
          m3l_DestroyFound(&Founds);

          if(*g_time < *$stime + *$dtmax*0.4){
            *g_time = *$stime + *$dtmax ;
             simulation_time = *g_time;
             delta_t = *$dtmax;
             time_shift = 1;
          }
          else{
             simulation_time = *g_time;
             delta_t = *$dtmax;
             time_shift = 0;
          }
        }


        int cnt = 0 ; 
        int lenvec = len *3;
        const int mi = 1;

        FORALL(intsurf,ii) {
            
           int ind1 = m3l_get_2ind(cnt,0,3);
           int ind2 = m3l_get_2ind(cnt,1,3);
           int ind3 = m3l_get_2ind(cnt,2,3);
            
           forces[ind1] = $iflux[ii][mi+0]; 
           forces[ind2] = $iflux[ii][mi+1]; 
           forces[ind3] = $iflux[ii][mi+2];
           
           coords[ind1] = $facecenter[ii].x;
           coords[ind2] = $facecenter[ii].y;
           coords[ind3] = $facecenter[ii].z;
                      
           cnt++ ;

        }ENDFORALL ;
/*
 * gather data
 */         
        GatherDVec(forcesg, forces, lenvec, comm);
        GatherDVec(coordsg, coords, lenvec, comm);

        if(Loci::MPI_rank==0) {
             
           for(lmsize_t i = 0 ; i< (*$extInterfaceNameStr(X,Y)).INTF_totdomsize; i++){
           
               int ind1 = m3l_get_2ind(i,0,3);
               int ind2 = m3l_get_2ind(i,1,3);
               int ind3 = m3l_get_2ind(i,2,3);
          
//                 std::cout << "PNE "  << i << "  "<< forcesg[ind1]  << " " << forcesg[ind2] << " " << forcesg[ind3]  <<endl ;
           }
           
           std::cout << "CMMMMMMMMMMMMMMMMMMMMMM "  << simulation_time <<endl ;
/*
 * this is rigid body motion interface, sends away forces and gets back quaternion, translation and 
 * center of rotation
 */
//            Snode = bridge_aeroelastic(IntfNode, pcomm_str);
// 
//            if(m3l_Umount(&Snode) != 1)
// 		     Perror("solverExternalComm - aeroelastic: m3l_Umount");
        }
/*
 * scatter data
 */        
        ScatterDVec(displacementsg, displacements, lenvec, comm); 
        
        FORALL(intsurf,ii) {
//           vect3d p1 = $pos[$face2node[ii][0]] ;
//           vect3d p2 = $pos[$face2node[ii][1]] ;
//           vect3d p3 = $pos[$face2node[ii][2]] ;
//           vect3d p4 = $pos[$face2node[ii][3]] ;
            
           int ind1 = m3l_get_2ind(cnt,0,3);
           int ind2 = m3l_get_2ind(cnt,1,3);
           int ind3 = m3l_get_2ind(cnt,2,3);
            
//            $face2node[ii][0]->$nodeDisp_b = vect3d(0., 0., 0.);
           
           $nodeDisp_b[$face2node[ii][0]] = vect3d(0., 0., 0.);
           $nodeDisp_b[$face2node[ii][2]] = vect3d(0., 0., 0.);
           $nodeDisp_b[$face2node[ii][3]] = vect3d(0., 0., 0.);
           $nodeDisp_b[$face2node[ii][4]] = vect3d(0., 0., 0.);

// 		   cnt++ ;

        }ENDFORALL ;  
        
        
//         componentXform xform ;
// 
//         string name = *$componentName_X;
//        (*$componentMotionData)[name] = xform;
        
   };
   
   
   
   

/*
 * rigid-elastic body motion interface (expot forces,get back rgid body motion)
 * ====================================================================================
 */


/*
 */
   $rule apply(componentMotionData<-ncycle, stime, dtmax,ext_interfaces,extInterfaceNameStr(X,Y),
                 componentName_X,extInterfaceName(X,Y),volumeTag(X),ConstextInterfaceName(X,Y),
                 face2node, pos,facecenter,iflux,area, gagePressure_f )[Loci::NullOp], 
                 parametric(extInterfaceName(X,Y)),
                 constraint(ConstextInterfaceName(X,Y),volumeTag(X),componentExternalRigidElastic_X_Y), 
                 prelude{
/*
 * if interface is "active" communicate
 */
    find_t *Founds=NULL;
    node_t *IntfNode, *local_data, *global_data, *FoundNode;
    char buffer [80];
    lmdouble_t *forces, *forcesg, *g_time, *coords, *coordsg;
    
    real t = *$stime + *$dtmax ;

    lmdouble_t RotCX, RotCY,  RotCZ;
    lmdouble_t TransX, TransY, TransZ;
    lmdouble_t Alpha, Qx, Qy, Qz;
    lmdouble_t ForceX, ForceY, ForceZ, simulation_time, delta_t, *angle ;
    componentXform xform ;
    lmsize_t *dims, *domsize;
    double pitch;
    int time_shift;

    time_shift = 0;

    if(Loci::MPI_rank==0) 
      m3l_Cat(Gnode, "--detailed", "-L", "-P", "*",   (lmchar_t *)NULL);
/*
 * find interface with file Name with name *$extInterfaceName(X,Y) in it
 */
       string str_intfname =  *$extInterfaceName(X,Y) ;
       string str_voltagname =  *$volumeTag(X) ;
       const char *srt = str_intfname.c_str(); 
       sprintf (buffer, "/*/SV_Name=%s", srt);
/*
 * locate interface, clean allocated memory
 */      
      if( (Founds = m3l_Locate(Gnode, "/Interfaces/Interface", buffer,  (lmchar_t *)NULL)) != NULL){
          
          IntfNode = m3l_get_Found_node(Founds, 0);
          m3l_DestroyFound(&Founds);

      }
      else{
          Perror("Did not find aeroleastic interface");
      }
/*
 * loop over fact database with interfaces and find if it is there
 */
      comm_struct_t comm_str, *pcomm_str;
      pcomm_str = &comm_str;
      Loci::storeRepP sp;
      Loci::fact_db* facts = Loci::exec_current_fact_db ;    

      MPI_Comm comm  = MPI_Comm_f2c((*$extInterfaceNameStr(X,Y)).INTF_comm); 
/*
 * get simulation time
 */
    //       (*$extInterfaceNameStr(X,Y)).INTF_docommunicate = false;
      string commtype;
      Loci::options_list::arg_list Vol_tags, *pVol_tags;
      pVol_tags = &Vol_tags;
  	  Map l2g ;
      
      if(Loci::MPI_rank==0) {
        std::cout << "Looking for interface  - " <<  *$extInterfaceName(X,Y)  << std::endl ; 
/*
 * identify interface
 */
        if( ident_intf(pVol_tags, *$ext_interfaces, pcomm_str, *$extInterfaceName(X,Y), "aeroelasticity_rigid")){
/*
 * check that type among allowed types of interfaces
 */
          lmsize_t clen = strlen(pcomm_str->type);
          if(strncmp(pcomm_str->type, "aeroelasticity_rigid", clen) != 0 ){

            std::cerr << "ERROR: unknown type of interface (3-2) '" << pcomm_str->type << "', check settings in .vars file" << std::endl ;
            exit(-1) ;

          }
        }
        else{
            std::cerr << "ERROR(3): did not find interface - " << *$extInterfaceName(X,Y)  << " - , check settings in .vars file" << std::endl ;
            exit(-1) ;
        }
       }
         
        lmsize_t len = (*$extInterfaceNameStr(X,Y)).INTF_domsize;

        string IntfName = "LocConstextInterfaceName("+str_voltagname+","+str_intfname+")"; 
        Loci::fact_db::distribute_infoP df = 0;         
        if(facts->is_distributed_start())
	      df = facts->get_distribute_info();

        sp = facts->get_variable(IntfName) ;
        Loci::entitySet intsurf = entitySet(sp->domain()) ;
         
        if(df!=0) {
	       intsurf &= df->my_entities ;
//            l2g = df->l2g.Rep() ;
        }
/*
 * find vector of local forces and displacements, on the root partition,find 
 * global vectors too. Omit all checks, proper coding would require to so si
 */
        Founds = m3l_Locate(IntfNode, "./Interface/local_data", "/*/*",  (lmchar_t *)NULL);
/*
 */
        local_data = m3l_get_Found_node(Founds, 0);
        m3l_DestroyFound(&Founds);
        
        if(comm != MPI_COMM_NULL && len > 0){
        
            Founds = m3l_Locate(local_data, "./local_data/Forces", "/*/*",  (lmchar_t *)NULL);
/*
 */	
            FoundNode = m3l_get_Found_node(Founds, 0);
            forces =(lmdouble_t *)m3l_get_data_pointer(FoundNode);
            m3l_DestroyFound(&Founds);
        
            Founds = m3l_Locate(local_data, "./local_data/coordinates", "/*/*",  (lmchar_t *)NULL);
/*
 */	
            FoundNode = m3l_get_Found_node(Founds, 0);
            coords =(lmdouble_t *)m3l_get_data_pointer(FoundNode);
            m3l_DestroyFound(&Founds);

        }
        
        if(Loci::MPI_rank==0) {
          Founds = m3l_Locate(IntfNode, "./Interface/global_data", "/*/*",  (lmchar_t *)NULL);
/*
 */
          global_data = m3l_get_Found_node(Founds, 0);
          m3l_DestroyFound(&Founds);
        
          Founds = m3l_Locate(global_data, "./global_data/Forces", "/*/*",  (lmchar_t *)NULL);
/*
 */
          FoundNode = m3l_get_Found_node(Founds, 0);
          forcesg =(lmdouble_t *)m3l_get_data_pointer(FoundNode);
          m3l_DestroyFound(&Founds);
          
          Founds = m3l_Locate(global_data, "./global_data/coordinates", "/*/*",  (lmchar_t *)NULL);
/*
 */
          FoundNode = m3l_get_Found_node(Founds, 0);
          coordsg = (lmdouble_t *)m3l_get_data_pointer(FoundNode);
          dims = m3l_get_List_dim(FoundNode);
          m3l_DestroyFound(&Founds);

          Founds = m3l_Locate(global_data, "./global_data/time", "/*/*",  (lmchar_t *)NULL);
/*
 */
          FoundNode = m3l_get_Found_node(Founds, 0);
          g_time =(lmdouble_t *)m3l_get_data_pointer(FoundNode);
          m3l_DestroyFound(&Founds);

          Founds = m3l_Locate(global_data, "./global_data/modangle", "/*/*",  (lmchar_t *)NULL);
/*
 */
          FoundNode = m3l_get_Found_node(Founds, 0);
          angle =(lmdouble_t *)m3l_get_data_pointer(FoundNode);
          m3l_DestroyFound(&Founds);

          if(*g_time < *$stime + *$dtmax*0.4){
            *g_time = *$stime + *$dtmax ;
             simulation_time = *g_time;
             delta_t = *$dtmax;
             time_shift = 1;
          }
          else{
             simulation_time = *g_time;
             delta_t = *$dtmax;
             time_shift = 0;
          }
        }

        int cnt = 0 ; 
        int lenvec = len *3;
        const int mi = 1;

        FORALL(intsurf,ii) {
            
           int ind1 = m3l_get_2ind(cnt,0,3);
           int ind2 = m3l_get_2ind(cnt,1,3);
           int ind3 = m3l_get_2ind(cnt,2,3);
            
           forces[ind1] = $iflux[ii][mi+0];
           forces[ind2] = $iflux[ii][mi+1];
           forces[ind3] = $iflux[ii][mi+2];
           
//            forces[ind1] = $gagePressure_f[ii] * $area[ii].n.x * $area[ii].sada;
//            forces[ind2] = $gagePressure_f[ii] * $area[ii].n.y * $area[ii].sada;
//            forces[ind3] = $gagePressure_f[ii] * $area[ii].n.z * $area[ii].sada; 
           
           coords[ind1] = $facecenter[ii].x;
           coords[ind2] = $facecenter[ii].y;
           coords[ind3] = $facecenter[ii].z;
                      
	        cnt++ ;
            
//             std::cout << "Looking for interface  - " <<   $facecenter[ii] << "   " <<   forces[ind1] << "  "  <<forces[ind2] << "  "  << forces[ind3] << std::endl ; 
            

        }ENDFORALL ;
/*
 * gather data
 */
        GatherDVec(forcesg, forces, lenvec, comm);
        GatherDVec(coordsg, coords, lenvec, comm);
// 
        if(Loci::MPI_rank==0) {
/*
 * this is rigid body motion interface, sends away forces and gets back quaternion, translation and 
 * center of rotation
 */
 //        bridge_aeroelastic_rigid(IntfNode, &Alpha, &Qx, &Qy, &Qz,
//                    &TransX, &TransY, &TransZ, &RotCX, &RotCY, &RotCZ, pcomm_str);
// 
           double MomentY = 0;
           vect3d Moment = vect3d(0., 0., 0.);

           for(int inodes = 0; inodes < dims[0]; inodes++){
/*
 *  for Jurgen
 */    
             int ind1 = m3l_get_2ind(inodes,0,3);
             int ind2 = m3l_get_2ind(inodes,1,3);
             int ind3 = m3l_get_2ind(inodes,2,3);
/*
 * these are x,y, coordinates of boundary face centers
 */               
             double X = coordsg[ind1];
             double Y = coordsg[ind2];
             double Z = coordsg[ind3];
/*
 * these are fx,fy,fz force components  of boundary face centers
 */ 
             double FX = forcesg[ind1];
             double FY = forcesg[ind2];
             double FZ = forcesg[ind3];
             
//              printf(" %lf %lf %lf %lf %lf %lf \n", X,Y,Z, FX,FY,FZ);

             double rotcx = 0.075;
             double rotcy = 0.;
             double rotcz = 0.;

             double vecx = X -  rotcx;
             double vecy = Y -  rotcy;
             double vecz = Z -  rotcz;

             MomentY = MomentY + vecx*FZ - vecz*FX;
             
            const vect3d delta = vect3d(X-0.075, Y, Z);
            const vect3d momentum_flux = vect3d(FX, FY, FZ) ;
            const vect3d dmom = cross(delta,momentum_flux) ;
            
//             std::cout << "Looking for interface  - " <<   delta << "   " <<   FX << "  "  <<FY<< "  "  << FZ << std::endl ; 
            
//              std::cout << momentum_flux << endl;
            
            Moment = Moment - dmom;
             
           }
              MomentY = Moment[1];
           
//            exit(-1);
/*
 * structural equations constants
 */
//             double Imom    = 0.0012;
//             double damping = 0.0106;
//             double Kstiff  = 0.795;

             double Imom    = 0.0023;
             double damping = 0.0136;
             double Kstiff  = 0.7964;
/*
 * approximations: 
 *
 *  second order backward first and second derivative
 * 
 *  f'  = (3f_i - 4f_i-1 + f_i-2)/2h
 *  f'' = (2f_i - 5f_i-1 + 4f_i-2-f_i-3)/h^2
 */    
             double term1 = Imom*(-5*angle[1] + 4*angle[2] - angle[3])/(delta_t*delta_t);
             double term2 = damping * (-4*angle[1]+angle[2])/(2*delta_t);

             angle[0] = -MomentY - term1 - term2;
             angle[0] = angle[0] /(2*Imom/(delta_t*delta_t) + 3*damping/(2*delta_t) + Kstiff);
/*
 * if first step, prescribe derivative of alpha
 */
             if(simulation_time - delta_t < delta_t) angle[0] = 0.1*delta_t;
             
             if(simulation_time - delta_t < 0.05) angle[0] = 25*sin(2.5*2*3.1415926*simulation_time)*3.1415926/180;
             
             angle[0] = 10*sin(3.1415926*10*(simulation_time))*3.1415926/180.;
             
            // angle[0] = 0.016+2.51*sin(simulation_time*2*3.1415926*6.6565344171)*3.1415926/180;   // CT5 case
/*
 * shift in time
 */
             pitch = angle[0];

             if(time_shift == 1){
               angle[3] = angle[2];
               angle[2] = angle[1];
               angle[1] = angle[0]; 
             

               std::ofstream outfile;
               outfile.open("DATA.txt", std::ios_base::app);
               outfile << simulation_time - delta_t << "  " << angle[0]*180./3.1415926 << "   " << Moment <<  endl;
               outfile.close();
             }
/*
 * here get pitch, roll, yaw agle
 */
//             pitch = angle[0];
          //  double pitch = 0.016+2.51*sin(simulation_time*2*3.1415926*6.6565344171);
             double yaw = 0;
             double roll = 0;
            
             printf(" ----------------------->  Pitch angle is  %lf    %lf\n", pitch*180./3.1415926, simulation_time);

/*
 * transform angles to radiand if needed
 */            
//            pitch = pitch *3.1415926/180.;
//            yaw = yaw *3.1415926/180.;
//            roll = roll *3.1415926/180.;
/*
 * set center of rotation
 */
            RotCX = 0.075;
            RotCY = 0.;
            RotCZ = 0.;
/*
 * displacement ....
 */
           TransX = 0;
           TransY = 0;
           TransZ = 0;
/*
 * calculate quaternion
 */
            double cy = cos(yaw * 0.5);
            double sy = sin(yaw * 0.5);
            double cr = cos(roll * 0.5);
            double sr = sin(roll * 0.5);
            double cp = cos(pitch * 0.5);
            double sp = sin(pitch * 0.5);

            Alpha = cy * cr * cp + sy * sr * sp;
            Qx     = cy * sr * cp - sy * cr * sp;
            Qy     = cy * cr * sp + sy * sr * cp;
            Qz     = sy * cr * cp - cy * sr * sp;

         }
/*
 * broadcast and save in XmotionData structure
 */
        MPI_Bcast(&TransX,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&TransY,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&TransZ,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&RotCX,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&RotCY,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&RotCZ,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&Alpha,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&Qx,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&Qy,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        MPI_Bcast(&Qz,1,MPI_DOUBLE,0,MPI_COMM_WORLD) ;
        
        vect3d cg ;     //= vect3d (1.0,1.0,1.0) ;
        vect3d cg_new;
        
        cg         = vect3d(RotCX, RotCY, RotCZ);
        cg_new = vect3d(TransX, TransY, TransZ);
        cg_new = cg + cg_new;

        xform.cg = cg;
        xform.new_cg = cg_new ;
        xform.q.x = Qx ;
        xform.q.y = Qy ;
        xform.q.z = Qz ;
        xform.q.w = Alpha;

        string name = *$componentName_X;
       (*$componentMotionData)[name] = xform;
       
   };
/*
 * elastic body motion interface
 * ====================================================================================
 */
   
   $rule pointwise(OUTPUT<-iflux),
    constraint(ConstextInterfaceName(X,Y),GM_timeLaggedCouplingMode),parametric(extInterfaceName(X,Y))
    {
    };
    
    
//    $type boundaryName(X) param<string>  ;    
//    $rule pointwise(OUTPUT{n=0}<-boundaryName(X)),parametric(boundaryName(X)),
//     prelude {
//        std::cout << "bcnammmmmmmmmm "  <<  *$boundaryName(X)  <<endl ;
//   } ;
    
}

#else
/*
 * in case of not having libm3l and lsipdx 
 */
namespace flowPsi { 


  $rule singleton(XmotionData(X)<-dtmax,stime), 
    constraint(componentExternalRigid_X_Y),parametric(volumeTag(X)){
    if(Loci::MPI_rank==0) {
      cerr << " " << endl ;
      cerr << "ERROR: Current version of flowPsi not compiled with libm3l and lsidpx support" << endl ;
      cerr << "componentMotion: external not supported" << endl ;
      cerr << "Exiting ...  " << endl ;
    }
    exit(-1) ;
  };

}

#endif




