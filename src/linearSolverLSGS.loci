//#############################################################################
//#
//# Copyright 2015, Mississippi State University
//#
//# This file is part of the flowPsi computational fluid dynamics solver.
//#
//# The flowPsi solver is free software: you can redistribute it and/or modify
//# it under the terms of the GNU General Public License as published by
//# the Free Software Foundation, either version 3 of the License, or
//# (at your option) any later version.
//#
//# The flowPsi solver is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# GNU General Public License for more details.
//#
//# You should have received a copy of the GNU General Public License
//# along with the flowPsi solver.  If not, see <http://www.gnu.org/licenses>
//#
//#############################################################################

#include <Loci.h>
#include "periodic.h"
#include <vector> 
#include <algorithm>
#include <set>
#include "flowTypes.h"
$include "flowPsi.lh"

//#define JACOBI
// Scalar solver using modified line gauss seidel method
namespace LGSI {
#ifdef USE_AUTODIFF
#ifdef AUTODIFF2ND
#define LSGS_TYPE Loci::MPI_FADD2
#else
#define LSGS_TYPE Loci::MPI_FADD 
#endif
#else	
#define LSGS_TYPE MPI_DOUBLE
#endif
  using flowPsi::real ;
  using flowPsi::real_fj ;
  using flowPsi::realF ;
  using Loci::realToDouble ;
  using std::vector ;
  using std::sort ;
  using std::swap ;
  using std::set ;
  using std::cerr ;
  using std::endl ;  
  typedef real real ;
  // Scalar solve
  $type X_B store<real> ;
  $type X_D store<real> ;
  $type X_L store<real> ;
  $type X_U store<real> ;
  $type LSGSConnectivity(X) store<realF> ;

  $type LSGSRelaxation param<real> ;
  $type LSGSAbsTol param<double> ;
  $type LSGSRelTol param<double> ;
  $type LSGSMaxIter param<int> ;

  $rule default(LSGSRelaxation) {
    $LSGSRelaxation = 0.3 ;
  }
  $rule default(LSGSAbsTol) {
    $LSGSAbsTol = 1e-10 ;
  }
  $rule default(LSGSRelTol) {
    $LSGSRelTol = 0.1 ;
  }

  $rule default(LSGSMaxIter) {
    $LSGSMaxIter = 10 ;
  }

  $rule pointwise(LSGSConnectivity(X)<-X_L,X_U),parametric(LSGSScalarSolve(X)) {
    $LSGSConnectivity(X) = max(fabs($X_L),fabs($X_U)) ;
  }

  $type LSGSmatrixPeriodic blackbox<std::vector<pair<int,int> > > ;

  $rule unit(LSGSmatrixPeriodic),constraint(UNIVERSE),prelude {
    $LSGSmatrixPeriodic = vector<pair<int,int> >() ;
  } ;

  $rule apply(LSGSmatrixPeriodic)[Loci::NullOp],constraint(geom_cells), prelude { } ;
  
  $rule apply(LSGSmatrixPeriodic<-cr->fileNumber(geom_cells),pmap->cl->fileNumber(geom_cells))[Loci::NullOp], option(disable_threading), prelude {
    Loci::entitySet pset = Loci::entitySet(seq) ;
    FORALL(pset,ii) {
      int i1 = $cr[ii] ;
      int i2 = $cl[$pmap[ii]] ;
      ($LSGSmatrixPeriodic)->push_back(pair<int,int>(i1,i2)) ;
    } ENDFORALL ;
  } ;

  
  $type LSGSmatrixInitialize(X) blackbox<int> ;
  $type LSGSmatrixTopology(X) blackbox<int> ;
  
  struct lineLayout {
    int eqnstart,eqnend,Lstart,Ustart,OuterStart,OuterEnd ;
  } ;

  struct matrixStructure {
    int access_counter ;
    int nmyeqn ;
    // equation variable map
    vector<int> eql2g ; // Local to global map for equation information
    // line information
    vector<lineLayout> lineData ;
    // maximum line length
    int mxlinelen ;
    // Global to local map for off diagonal matrix information
    const_Map globalL2l,globalU2l ;
    // connectivity information
    vector<pair<int,int> > outerCLR ; // outer face left/right eqn numbers
    //
    // Communication structure
    vector<int> send_processors ;
    vector<int> send_offsets ;
    vector<int> send_entities ;
    vector<int> send_entitiesl ;
    vector<int> recv_processors ;
    vector<int> recv_offsets ;
    vector<int> recv_entities ;
    vector<int> recv_entitiesl ;

    vector<pair<int,int> > periodicCopy ;
    matrixStructure(const matrixStructure &ms) {
      access_counter = ms.access_counter ;
      nmyeqn = ms.nmyeqn ;
      eql2g = ms.eql2g ;
      lineData = ms.lineData ;
      mxlinelen = ms.mxlinelen ;
      outerCLR = ms.outerCLR ;
      globalL2l.setRep(ms.globalL2l.Rep()) ;
      globalU2l.setRep(ms.globalU2l.Rep()) ;
      send_processors = ms.send_processors ;
      send_offsets = ms.send_offsets ;
      send_entities = ms.send_entities ;
      send_entitiesl = ms.send_entitiesl ;
      recv_processors = ms.recv_processors ;
      recv_offsets = ms.recv_offsets ;
      recv_entities = ms.recv_entities ;
      recv_entitiesl = ms.recv_entitiesl ;
      periodicCopy = ms.periodicCopy ;
    }
    matrixStructure &operator=(const matrixStructure &ms) {
      access_counter = ms.access_counter ;
      nmyeqn = ms.nmyeqn ;
      eql2g = ms.eql2g ;
      lineData = ms.lineData ;
      mxlinelen = ms.mxlinelen ;
      outerCLR = ms.outerCLR ;
      globalL2l.setRep(ms.globalL2l.Rep()) ;
      globalU2l.setRep(ms.globalU2l.Rep()) ;
      send_processors = ms.send_processors ;
      send_offsets = ms.send_offsets ;
      send_entities = ms.send_entities ;
      send_entitiesl = ms.send_entitiesl ;
      recv_processors = ms.recv_processors ;
      recv_offsets = ms.recv_offsets ;
      recv_entities = ms.recv_entities ;
      recv_entitiesl = ms.recv_entitiesl ;
      periodicCopy = ms.periodicCopy ;
      return *this ;
    }
    matrixStructure() { access_counter = -1 ;}
  } ;

  vector<matrixStructure> matrixInfo ;

  struct scalarMatrixData {
    vector<real> B ;
    vector<real> D ;
    vector<real> F ;
  } ;

  $type LSGSscalarMatrix(X) blackbox<scalarMatrixData> ;

  $rule blackbox(LSGSmatrixInitialize(X)),constraint(UNIVERSE),prelude {
    $LSGSmatrixInitialize(X) = matrixInfo.size() ;
    matrixInfo.push_back(matrixStructure()) ;
  } ;

  $type LSGSdiagEntries(X) param<int> ;
  $rule singleton(LSGSdiagEntries(X)),constraint(X_D) {
    $LSGSdiagEntries(X) = 1 ;
  }
  
  $rule blackbox(LSGSmatrixTopology(X)<-cellcenter,LSGSmatrixPeriodic,
		 (lower,upper)->LSGSConnectivity(X),
		 lower->cl->LSGSdiagEntries(X),
		 upper->cr->LSGSdiagEntries(X),
		 LSGSdiagEntries(X),LSGSmatrixInitialize(X)),
      option(disable_threading),
    prelude {
    *$LSGSmatrixTopology(X) = *$LSGSmatrixInitialize(X) ;
    struct matrixStructure &matrix = matrixInfo[*$LSGSmatrixInitialize(X)] ;
    if(matrix.access_counter < 0) { 
	if(Loci::MPI_processes > 1) {
	  Loci::fact_db::distribute_infoP df = 
	    Loci::exec_current_fact_db->get_distribute_info() ;
	  Map l2g ;
	  l2g = df->l2g.Rep() ;
	  entitySet dom = $LSGSdiagEntries(X).domain() ;
	  entitySet mydom = dom ;
	  mydom &= df->my_entities ;
	  Loci::MapRepP clm = Loci::MapRepP($cl.Rep()) ;
	  Loci::MapRepP crm = Loci::MapRepP($cr.Rep()) ;
	  Loci::MapRepP lowerm = Loci::MapRepP($lower.Rep()) ;
	  Loci::MapRepP upperm = Loci::MapRepP($upper.Rep()) ;

	  entitySet access_dom = (clm->image(lowerm->image(mydom)) +
				  crm->image(upperm->image(mydom)) +
				  mydom) ;
      
	  // Temporary map from global back to local
	  std::map<int,int> g2l ;
	  FORALL(access_dom,ii) {
	    g2l[l2g[ii]] = ii ;
	  } ENDFORALL ;

	  // Entities that we access that we don't own in local numbering
	  Loci::entitySet localcom = access_dom-df->my_entities ;
	  // Entities that we need to recieve in global numbering
	  Loci::entitySet rset = Loci::MapRepP(l2g.Rep())->image(localcom) ;
	  std::vector<entitySet> &ptn = Loci::exec_current_fact_db->get_init_ptn() ;
	  vector<pair<int,vector<int> > > recv_sets ;
	  for(int i=0;i<Loci::MPI_processes;++i) {
	    entitySet rpset = rset & ptn[i] ;
	    if(rpset != EMPTY) {
	      if(i == Loci::MPI_rank) {
		cerr << "inconsistent self communcation found in line gsi code" << endl ;
		Loci::Abort() ;
	      }
	      vector<int> recv_set(rpset.size()) ;
	      int cnt = 0 ;
	      Loci::entitySet::const_iterator ei ;
	      for(ei=rpset.begin();ei!=rpset.end();++ei) {
		recv_set[cnt] = *ei ;
		cnt++ ;
	      }
	      recv_sets.push_back(pair<int,vector<int> >(i,recv_set)) ;
	    }
	  }
	  vector<int> recv_cnts(Loci::MPI_processes,0) ;
	  for(size_t i=0;i<recv_sets.size();++i) {
	    recv_cnts[recv_sets[i].first] = recv_sets[i].second.size() ;
	  }
	  vector<int> send_cnts(Loci::MPI_processes,0) ;
	  MPI_Alltoall(&recv_cnts[0],1,MPI_INT,&send_cnts[0],1,MPI_INT,
		       MPI_COMM_WORLD) ;
      
	  int cc = 0 ;
	  for(int i=0;i<Loci::MPI_processes;++i) {
	    if(send_cnts[i] > 0) 
	      cc++ ;
	  }

	  vector<pair<int,vector<int> > > send_sets(cc) ;
	  vector<MPI_Request> requests(cc) ;
	  
	  cc = 0 ;
	  for(int i=0;i<Loci::MPI_processes;++i) {
	    if(send_cnts[i] > 0) {
	      send_sets[cc] = pair<int,vector<int> >(i,vector<int>(send_cnts[i])) ;
	      MPI_Irecv(&(send_sets[cc].second[0]),send_cnts[i],MPI_INT,i,99,
			MPI_COMM_WORLD,&requests[cc]) ;
	      cc++ ;
	    }
	  }
	  for(size_t i=0;i<recv_sets.size();++i) {
	    int p = recv_sets[i].first ;
	    int sz = recv_sets[i].second.size() ;
	    MPI_Send(&(recv_sets[i].second[0]),sz,MPI_INT,p,99,MPI_COMM_WORLD) ;
	  }
	  vector<MPI_Status> status(requests.size()) ;
	  MPI_Waitall(requests.size(),&requests[0],&status[0]) ;
    
	  // Now convert send and recv lists to local numbering
	  for(size_t i=0;i<recv_sets.size();++i) {
	    int rsz = recv_sets[i].second.size() ;
	    for(int j=0;j<rsz;++j) {
	      std::map<int,int>::const_iterator ii = g2l.find(recv_sets[i].second[j]) ;
	      if(ii == g2l.end()) {
		cerr << "g2l undefined" << endl ;
		Loci::Abort() ;
	      }
	      recv_sets[i].second[j] = ii->second ;
	    }
	  }
	  for(size_t i=0;i<send_sets.size();++i) {
	    int ssz = send_sets[i].second.size() ;
	    for(int j=0;j<ssz;++j) {
	      std::map<int,int>::const_iterator ii = g2l.find(send_sets[i].second[j]) ;
	      if(ii == g2l.end()) {
		cerr << "g2l undefined" << endl ;
		Loci::Abort() ;
	      }
	      send_sets[i].second[j] = ii->second ;
	    }
	  }
	  // Assign communication info
	  matrix.send_processors = vector<int>(send_sets.size()) ;
	  matrix.send_offsets = vector<int>(send_sets.size()+1) ;
	  matrix.send_offsets[0] = 0 ;
	  int sendsize = 0; 
	  for(size_t i=0;i<send_sets.size();++i) {
	    matrix.send_processors[i] = send_sets[i].first ;
	    sendsize += send_sets[i].second.size() ;
	    matrix.send_offsets[i+1] = sendsize ;
	  }
	  matrix.send_entities = vector<int>(sendsize) ;
	  for(size_t i=0;i<send_sets.size();++i) 
	    for(size_t j=0;j<send_sets[i].second.size();++j)
	      matrix.send_entities[matrix.send_offsets[i]+j] 
		= send_sets[i].second[j] ;

	  matrix.recv_processors = vector<int>(recv_sets.size()) ;
	  matrix.recv_offsets = vector<int>(recv_sets.size()+1) ;
	  matrix.recv_offsets[0] = 0 ;
	  int recvsize = 0; 
	  for(size_t i=0;i<recv_sets.size();++i) {
	    matrix.recv_processors[i] = recv_sets[i].first ;
	    recvsize += recv_sets[i].second.size() ;
	    matrix.recv_offsets[i+1] = recvsize ;
	  }
	  matrix.recv_entities = vector<int>(recvsize) ;
	  for(size_t i=0;i<recv_sets.size();++i) 
	    for(size_t j=0;j<recv_sets[i].second.size();++j)
	      matrix.recv_entities[matrix.recv_offsets[i]+j] 
		= recv_sets[i].second[j] ;
	} else {
	  // Assign communication info
	  matrix.send_processors = vector<int>(0) ;
	  matrix.send_offsets = vector<int>(1) ;
	  matrix.send_offsets[0] = 0 ;
	  matrix.send_entities = vector<int>(0) ;

	  matrix.recv_processors = vector<int>(0) ;
	  matrix.recv_offsets = vector<int>(1) ;
	  matrix.recv_offsets[0] = 0 ;
	  matrix.recv_entities = vector<int>(0) ;
	}
      }
      
    if(matrix.access_counter < 0 || matrix.access_counter > 20) {
      matrix.access_counter = 0 ;
      // Build temporary connectivity matrix

      entitySet dom = ($lower.domain() & $upper.domain()) ;
      entitySet mydom = dom ;
	
      if(Loci::MPI_processes > 1)
        mydom &= Loci::exec_current_fact_db->get_distribute_info()->my_entities ;

      Loci::MapRepP clm = Loci::MapRepP($cl.Rep()) ;
      Loci::MapRepP crm = Loci::MapRepP($cr.Rep()) ;
      Loci::MapRepP lowerm = Loci::MapRepP($lower.Rep()) ;
      Loci::MapRepP upperm = Loci::MapRepP($upper.Rep()) ;
      
      entitySet access_dom = (clm->image(lowerm->image(mydom)) +
			      crm->image(upperm->image(mydom)) +
			      mydom) ;
      dom += access_dom ;
      if($LSGSmatrixPeriodic->size() > 0) {
	vector<int> val($LSGSmatrixPeriodic->size()*2) ;
	for(size_t i=0;i<$LSGSmatrixPeriodic->size();++i) {
	  val[i*2] = (*$LSGSmatrixPeriodic)[i].first ;
	  val[i*2+1] = (*$LSGSmatrixPeriodic)[i].second ;
	}
	entitySet pdom = create_entitySet(val.begin(),val.end()) ;
	dom += pdom ;
      }

      const int dsz = dom.size() ;
      vector<int> index(dsz) ;
      Map toeqn ;
      toeqn.allocate(dom) ;
      int cnt = 0 ;
      // First number all equations owned by this processor
      const int nmyeqn = mydom.size() ;
      FORALL(mydom,ii) {
        index[cnt] = ii ;
        toeqn[ii] = cnt ;
        cnt++ ;
      } ENDFORALL ;
      // Then number equations referenced by this processor
      entitySet remainder = dom-mydom ;
      FORALL(remainder,ii) {
        index[cnt] = ii ;
        toeqn[ii] = cnt ;
        cnt++ ;
      } ENDFORALL ;
      //    cout << "nmyeqn=" << nmyeqn << ",rem = " << remainder.size() << endl ;
      vector<int> offsets(nmyeqn+1) ;
      offsets[0] = 0 ;
      cnt = 1 ;
      int totsz = 0 ;
      FORALL(mydom,ii) {
        const int lsz = $lower[ii].size() ;
        const int usz = $upper[ii].size() ;
        const int msz = lsz+usz ;
        totsz += msz ;
        offsets[cnt] = totsz ;
        cnt++ ;
      } ENDFORALL ;    

      vector<pair<int,int> > couples ;
      vector<int> neighbors(totsz) ;
      cnt = 0 ;
      FORALL(mydom,ii) {
        const int lsz = $lower[ii].size() ;
        const int usz = $upper[ii].size() ;
        const int msz = lsz+usz ;
        vector<int> cmap(msz) ;
        vector<realF> cval(msz) ;
        for(int i=0;i<lsz;++i) {
          cval[i] = $LSGSConnectivity(X)[$lower[ii][i]] ;
          cmap[i] = toeqn[$cl[$lower[ii][i]]] ;
          neighbors[offsets[cnt]+i] = cmap[i] ;
        }
        for(int i=0;i<usz;++i) {
          cval[i+lsz] = $LSGSConnectivity(X)[$upper[ii][i]] ;
          cmap[i+lsz] = toeqn[$cr[$upper[ii][i]]] ;
          neighbors[offsets[cnt]+i+lsz] = cmap[i+lsz] ;
        }
        cnt++ ;

        for(int i=1;i<msz;++i)
          if(cval[i] > cval[0]) {
            swap(cval[i],cval[0]) ;
            swap(cmap[i],cmap[0]) ;
          }
        for(int i=2;i<msz;++i)
          if(cval[i] > cval[1]) {
            swap(cval[i],cval[1]) ;
            swap(cmap[i],cmap[1]) ;
          }

        couples.push_back(pair<int,int>(toeqn[ii],cmap[0])) ;
        couples.push_back(pair<int,int>(cmap[0],toeqn[ii])) ;
	
	if(msz > 2 && cval[1]*25.0 > cval[0]) {
          couples.push_back(pair<int,int>(toeqn[ii],cmap[1])) ;
          couples.push_back(pair<int,int>(cmap[1],toeqn[ii])) ;
        }

      } ENDFORALL ;

      sort(couples.begin(),couples.end()) ;
      // If there are multiple faces to a cell then we will have
      // duplicate couples that will confuse the line search, so
      // we remove them.
      vector<pair<int,int> >::iterator di = unique(couples.begin(),couples.end()) ;
      if(di != couples.end()) {
	Loci::debugout << "duplicate couples detected in lsgs algorithm"
		       << endl ;
	couples.erase(di,couples.end()) ;
      }
      vector<pair<int,int> > connections(nmyeqn) ;
      
      for(int i=0;i<nmyeqn;++i) {
        connections[i].first = -1 ;
        connections[i].second = -1 ;
      }
#define LINES      
#ifdef LINES
      int csz = couples.size() ;
      for(int i=0;i<csz;) {
        int ncon = 1 ;
        int last = couples[i].second ;
        int l1 = -1 ;
        int l2 = -1 ;
        for(int j=i+1;j<csz;++j,ncon++) {
          if(couples[i].first != couples[j].first)
            break ;
          if(couples[j].second == last) {
            swap(l1,l2) ;
            swap(last,l1) ;
          }
          last = couples[j].second ;
        }
        if(l1 >= nmyeqn)
          l1 = -1 ;
        if(l2 >= nmyeqn)
          l2 = -1 ;
        if(couples[i].first < nmyeqn)
          connections[couples[i].first] = pair<int,int>(l1,l2) ;
      
        i+=ncon ;
      }
#endif
      //#define LINEJOIN1
#ifdef LINEJOIN1
      // If one of the broken links is filled by defaulting to it, then default
      for(int i=0;i<csz;) {
        int ncon = 1 ;
        for(int j=i+1;j<csz;++j,ncon++) {
          if(couples[i].first != couples[j].first)
            break ;
        }
        int eq = couples[i].first ;
        if(eq < nmyeqn && connections[eq].second == -1) {
          // try connecting
          for(int j=i;j<i+ncon;++j) {
            if(connections[eq].first != couples[j].second &&
               couples[j].second < nmyeqn &&
               connections[couples[j].second].second == -1) {
              connections[eq].second = couples[j].second ;
              connections[couples[j].second].second = eq ;
              break ;
            }
          }
        }
        i+=ncon ;
      }
#endif

      vector<int> lineNo(dsz,-2) ;
      FORALL(mydom,ii) {
        lineNo[toeqn[ii]] = -1 ;
      } ENDFORALL ;
      int lineno = 0 ;
      int cutcnt = 0 ;

      for(int i=0;i<nmyeqn;++i) {
        if(lineNo[i] == -1) {
          // scan line forward
        
          lineNo[i] = lineno ;
          int last = i ;
          int cx =0 ;
          int next = connections[last].second ;
          while(next >= 0) {
            if(connections[next].second == last)
              swap(connections[next].first,connections[next].second) ;
            if(connections[next].first != last) {
              cerr << "line data inconsistent, forward search" << endl ;
              cerr << "looking for " << last << " found "
                   << connections[next].first << " , "
                   << connections[next].second << ", next=" << next
                   << ",last=" << last 
                   << ",cx =" << cx << endl ;
            }
            cx++ ;
            int nmy = 0 ;
            for(int j=offsets[next];j<offsets[next+1];++j) {
              if(lineNo[neighbors[j]] == lineno)
                nmy++ ;
            }
            if( nmy > 1 || lineNo[next] != -1) {
              // cut line here
              //            cout << "cutting line " << lineno << ' ' << nmy << endl ;
              cutcnt++ ;
              connections[last].second = -1 ;
              connections[next].first = -1 ;
              next = -1 ;
            } else {
              lineNo[next] = lineno ;
              last = next ;
              next = connections[last].second ;
            }
          }
          // now scan backwards (if line was a loop, forward search cut the loop
          last = i ;
          next = connections[last].first ;
          while(next >= 0) {
            if(connections[next].first == last)
              swap(connections[next].first,connections[next].second) ;
            if(connections[next].second != last) {
              cerr << "line data inconsistent, backward search" << endl ;
              cerr << "looking for " << last << " found " << connections[next].first << " , " << connections[next].second << endl ;
            }
            int nmy = 0 ;
            for(int j=offsets[next];j<offsets[next+1];++j) {
              if(lineNo[neighbors[j]] == lineno)
                nmy++ ;
            }
            if( nmy > 1 || lineNo[next] != -1) {
              // cut line here
              //            cout << "cutting line " << lineno << ' ' << nmy << endl ;
              cutcnt++ ;
              connections[last].first = -1 ;
              connections[next].second = -1 ;
              last = next ;
              next = -1 ;
            } else {
              lineNo[next] = lineno ;
              last = next ;
              next = connections[last].first ;
            }

          }
          lineno++ ;
        }
      }
      // Create list of lines
      vector<pair<int,int> > lineinfo(lineno) ;
      for(int i=0;i<nmyeqn;++i) {
        if(connections[i].first == -1)
          lineinfo[lineNo[i]].first = i ;
        if(connections[i].second == -1)
          lineinfo[lineNo[i]].second = i ;
      }
      // try merge lines
      //#define MERGE
#ifdef MERGE
      int nmerge = 0 ;
      for(int i=0;i<lineno;++i) {
        // search first part of line to glue
        int l1 = lineinfo[i].first ;
        for(int j=offsets[l1];j<offsets[l1+1];++j)
          if(neighbors[j] < nmyeqn &&
             (connections[neighbors[j]].first == -1 ||
              connections[neighbors[j]].second == -1)) {
            // potential connection candidate, check to see if adding to this
            // line would cause line to self reference
            int candidate_line_no = lineNo[neighbors[j]] ;
            int ncandidate = 0 ;
            for(int k=offsets[l1];k<offsets[l1+1];++k) {
              if(lineNo[neighbors[k]] == candidate_line_no)
                ncandidate++ ;
            }
            if(ncandidate == 1) { // potentially safe to merge lines
              // now check to make sure
              int next = connections[l1].second ;
              while(next!=-1) {
                for(int k=offsets[next];k<offsets[next+1];++k) {
                  if(lineNo[neighbors[k]] == candidate_line_no)
                    ncandidate++ ;
                }
                next = connections[next].second ;
              }
              // glued line should not have itself as a neighbor
              if(ncandidate == 1) { // OK to glue lines
                if(connections[neighbors[j]].second == -1) {
                  next = l1 ;
                  while(next != -1) {
                    lineNo[next] = candidate_line_no ;
                    next = connections[next].second ;
                  }
                  connections[neighbors[j]].second = l1 ;
                  connections[l1].first = neighbors[j] ;
                  lineinfo[candidate_line_no].second = lineinfo[i].second ;
                  lineinfo[i].first=-1 ;
                  lineinfo[i].second=-1 ;
                  nmerge++ ;
                } else {
                  next = l1 ;
                  while(next != -1) {
                    lineNo[next] = candidate_line_no ;
                    swap(connections[next].second,connections[next].first) ;
                    next = connections[next].first ;
                  }
                  connections[neighbors[j]].first = l1 ;
                  connections[l1].second = neighbors[j] ;
                  lineinfo[candidate_line_no].first = lineinfo[i].second ;
                  lineinfo[i].first = -1 ;
                  lineinfo[i].second = -1 ;
                }
                break ;
              }
            }
          }
        // search end of line to glue
        int l2 = lineinfo[i].second ;
        if(l2 == -1) continue ;
      
        for(int j=offsets[l2];j<offsets[l2+1];++j)
          if(neighbors[j] < nmyeqn &&
             (connections[neighbors[j]].first == -1 ||
              connections[neighbors[j]].second == -1)) {
            // potential connection candidate, check to see if adding to this
            // line would cause line to self reference
            int candidate_line_no = lineNo[neighbors[j]] ;
            int ncandidate = 0 ;
            for(int k=offsets[l2];k<offsets[l2+1];++k) {
              if(neighbors[k] < nmyeqn && 
		 lineNo[neighbors[k]] == candidate_line_no)
                ncandidate++ ;
            }
            if(ncandidate == 1) { // potentially safe to merge lines
              // now check to make sure
              int next = connections[l2].first ;
              while(next!=-1) {
                for(int k=offsets[next];k<offsets[next+1];++k) {
                  if(neighbors[k] < nmyeqn &&
		     lineNo[neighbors[k]] == candidate_line_no)
                    ncandidate++ ;
                }
                next = connections[next].first ;
              }
              // glued line should not have itself as a neighbor
              if(ncandidate == 1) { // OK to glue lines
                if(connections[neighbors[j]].first == -1) {
                  next = l2 ;
                  while(next != -1) {
                    lineNo[next] = candidate_line_no ;
                    next = connections[next].first ;
                  }
                  connections[neighbors[j]].first = l2 ;
                  connections[l2].second = neighbors[j] ;
                  lineinfo[candidate_line_no].first = lineinfo[i].first ;
                  lineinfo[i].first=-1 ;
                  lineinfo[i].second=-1 ;
                  nmerge++ ;
                } else {
                  next = l2 ;
                  while(next != -1) {
                    lineNo[next] = candidate_line_no ;
                    swap(connections[next].second,connections[next].first) ;
                    next = connections[next].second ;
                  }
                  connections[neighbors[j]].second = l2 ;
                  connections[l2].first = neighbors[j] ;
                  lineinfo[candidate_line_no].second = lineinfo[i].first ;
                  lineinfo[i].first = -1 ;
                  lineinfo[i].second = -1 ;
                }
                break ;
              }
            }
          }
      }
      cout << "nmerge =" << nmerge << endl ;
#endif    

      // Order lines based on breadth first search.
      vector<int> line_order ;
      vector<int> line_visit(lineno,0) ;
      set<int> linedata ;
      int sp = 0 ;
      while(int(line_order.size()) != lineno) {
        if(linedata.empty()) {
          while(sp < lineno && line_visit[sp] != 0)
            sp++;
          if(sp == lineno) {
            // Finished with line list so exit loop
            break ;
          }
          linedata.insert(sp) ;
          line_visit[sp] = 1 ;
        }
        set<int> linedata_next ;
        set<int>::const_iterator ii ;
        for(ii=linedata.begin();ii!=linedata.end();++ii) {
          int l = *ii ;
          for(int j=lineinfo[l].first;j>=0;j=connections[j].second) {
            for(int k=offsets[j];k<offsets[j+1];++k) {
	      if(neighbors[k] < nmyeqn) {
		int nl =lineNo[neighbors[k]] ;
		if(line_visit[nl]==0) {
		  line_visit[nl] = 1 ;
		  linedata_next.insert(nl) ;
		}
              }
            }
          }
          if(lineinfo[l].first >=0)
            line_order.push_back(l) ;
        }
        linedata = linedata_next ;
      }
    
      // Now lines are sorted for SGS sweeps in line_order, now reorder eqns and
      // collect data structure for high performance implementation.
    
      vector<int> eqnorder(dsz) ;
      vector<int> eqnvisit(dsz,0) ;
      vector<int> line_offsets(line_order.size()+1) ;

      line_offsets[0] = 0 ;
      cnt = 0 ;
      for(size_t i=0;i<line_order.size();++i) {
        int ln = line_order[i] ;
        for(int j=lineinfo[ln].first;j>=0;j=connections[j].second) {
          if(eqnvisit[j] == 0) {
            eqnorder[cnt] = j ;
            cnt++ ;
            eqnvisit[j] = 1 ;
          } else {
            cerr << "equation visited by more than one line!" << endl ;
          }
        }
        line_offsets[i+1] = cnt ;
      }
      if(cnt != dsz) { // Number the remaining equations
        // Sort in order of first visited while scanning lines
        for(int i = nmyeqn-1;i>=0;--i) {
          for(int k=offsets[eqnorder[i]];k<offsets[eqnorder[i]+1];++k)
            if(neighbors[k] >= nmyeqn)
              eqnorder[neighbors[k]] = eqnorder[i] ;
        }
        vector<pair<int,int> > vpairs(dsz-nmyeqn) ;
        for(int i=nmyeqn;i<dsz;++i) {
          vpairs[i-nmyeqn].first = eqnorder[i] ;
          vpairs[i-nmyeqn].second = i ;
        }
        sort(vpairs.begin(),vpairs.end()) ;
        for(int i=nmyeqn;i<dsz;++i) {
          eqnorder[i] = vpairs[i-nmyeqn].second ;
        }
      }
      
      // build equation local 2 entity number map
      vector<int> eql2l(dsz) ; // map from old local number 2 new one
      { vector<int> eql2g(dsz) ;
	std::map<int,int> g2eql ;
        for(int i=0;i<dsz;++i) {
          eql2g[i] = index[eqnorder[i]] ;
	  g2eql[eql2g[i]] = i ;
          eql2l[eqnorder[i]] = i ;
        }
        matrix.eql2g.swap(eql2g) ;
	vector<int> recv_entitiesl(matrix.recv_entities.size()) ;
	for(size_t i=0;i<recv_entitiesl.size();++i)
	  recv_entitiesl[i] = g2eql[matrix.recv_entities[i]] ;
	matrix.recv_entitiesl.swap(recv_entitiesl) ;
	vector<int> send_entitiesl(matrix.send_entities.size()) ;
	for(size_t i=0;i<send_entitiesl.size();++i)
	  send_entitiesl[i] = g2eql[matrix.send_entities[i]] ;
	matrix.send_entitiesl.swap(send_entitiesl) ;
	matrix.nmyeqn = nmyeqn ;

	// Now handle periodic
	int psz = (*$LSGSmatrixPeriodic).size() ;
	vector<pair<int,int> > periodicCopy(psz) ;
	for(int i=0;i<psz;++i) {
	  periodicCopy[i].first = g2eql[(*$LSGSmatrixPeriodic)[i].first] ;
	  periodicCopy[i].second = g2eql[(*$LSGSmatrixPeriodic)[i].second] ;
	}
	matrix.periodicCopy.swap(periodicCopy) ;
      }
      
      // build line data structures
      int nlines = line_order.size() ;
      vector<lineLayout> lineData(nlines) ;

      matrix.mxlinelen = 0 ;
      cnt = 0 ;
      for(int i=0;i<nlines;++i) {
        int lsz = line_offsets[i+1]-line_offsets[i] ;
        matrix.mxlinelen = max(matrix.mxlinelen,lsz) ;
        lineData[i].eqnstart = line_offsets[i] ;
        lineData[i].eqnend = line_offsets[i+1] ;
        lineData[i].Lstart = cnt ;
        cnt += lsz-1 ;
        lineData[i].Ustart = cnt ;
        cnt += lsz-1 ;
        lineData[i].OuterStart = cnt ;
        for(int j=line_offsets[i];j<line_offsets[i+1];++j)
          cnt+= offsets[eqnorder[j]+1]-offsets[eqnorder[j]]-2 ;
        cnt += 2 ;
        lineData[i].OuterEnd = cnt ;
      }
      entitySet Ldom = Loci::MapRepP($lower.Rep())->image(mydom) ;
      entitySet Udom = Loci::MapRepP($upper.Rep())->image(mydom) ;
      Map globalL2l,globalU2l ;
      globalL2l.allocate(Ldom) ;
      globalU2l.allocate(Udom) ;
      vector<pair<int,int> > outerCLR(cnt) ;
      for(int i=0;i<nlines;++i) {
        int ln = line_order[i] ;
        // scan line and find line L and U
        int c1=lineData[i].Lstart ;
        int c2=lineData[i].Ustart ;
        int c3=lineData[i].OuterStart ;
        for(int j=lineinfo[ln].first;j>=0;j=connections[j].second) {
          // scan neighbors of this equation
          const int lsz = $lower[index[j]].size() ;
          for(int k=offsets[j];k<offsets[j+1];++k) {

            const int n =neighbors[k] ;
            int localid = -1 ;
            // find local id of this connection
            if(n == connections[j].first) {
              // L tridiagonal term
              localid = c1++ ;
            } else if(n == connections[j].second) {
              localid = c2++ ;
              // U tridiagonal term
            } else {
              // outer term
              localid = c3++ ;
            }
            // store connectivity
            outerCLR[localid].first = eql2l[j] ;
            outerCLR[localid].second = eql2l[n] ;
            int fid = (k-offsets[j]) ;
            // fill in matrix injection maps
            if(fid < lsz) {
              globalL2l[$lower[index[j]][fid]] = localid ;
            } else {
              globalU2l[$upper[index[j]][fid-lsz]] = localid ;
            }
          }
        }
      }

      matrix.globalL2l.setRep(globalL2l.Rep()) ;
      matrix.globalU2l.setRep(globalU2l.Rep()) ;
      matrix.outerCLR.swap(outerCLR) ;
      //#define PLOTFILE      
#ifdef PLOTFILE
      ofstream file2("plot.2dgv") ;
      file2 << "general" << endl ;
      file2 << nmyeqn << " 0" << endl ;
    
      for(int i=0;i<nmyeqn;++i) {
        file2 << $cellcenter[index[i]].x << ' ' << $cellcenter[index[i]].y << endl ;
      }
    
      file2 << nmyeqn << " 0 1 0" << endl ;
      for(int i=0;i<lineno;++i) {
        if(lineinfo[i].first >=0) {
          for(int j=lineinfo[i].first;j>=0;j=connections[j].second)
            if(connections[j].second >=0) {
              file2 << j << ' ' << connections[j].second << " 0 -1" << endl ;
            } else {
              file2 << j << ' ' << j << " 0 -1" << endl ;
            }
        }
      }
      for(int i=0;i<nmyeqn;++i)
        file2 << $cellcenter[index[i]].x << endl ;
#endif

      matrix.lineData = lineData ;
      //      cout << "mxlinelen=" << matrix.mxlinelen
      //           << ", #lines = " << lineData.size() << endl ;
      
    
    }
    
    matrix.access_counter++ ;
  } ;

  $rule blackbox(LSGSscalarMatrix(X)<-LSGSmatrixTopology(X),
		 X_B,X_D,upper->X_U,lower->X_L), prelude {
    struct matrixStructure & restrict matrix = matrixInfo[*$LSGSmatrixTopology(X)] ;
    vector<real> B(matrix.eql2g.size()); 
    vector<real> D(matrix.eql2g.size()); 
    vector<real> F(matrix.outerCLR.size()); 
    
    // Copy matrix into data structure
    for(int i=0;i<matrix.nmyeqn;++i) {
      D[i] = $X_D[matrix.eql2g[i]] ;
      B[i] = $X_B[matrix.eql2g[i]] ;
    }
    entitySet ldom  = matrix.globalL2l.domain() ;
    FORALL(ldom,ii) {
      F[matrix.globalL2l[ii]] = $X_L[ii] ;
    } ENDFORALL ;
    entitySet udom  = matrix.globalU2l.domain() ;
    FORALL(udom,ii) {
      F[matrix.globalU2l[ii]] = $X_U[ii] ;
    } ENDFORALL ;

    // Preprocess lines (recompute diagonal term)
    for(size_t l=0;l<matrix.lineData.size();++l) { // loop over lines
      real *L = &F[matrix.lineData[l].Lstart] ;
      real *U = &F[matrix.lineData[l].Ustart] ;
      real *restrict Dp = &D[matrix.lineData[l].eqnstart] ;
      int lsz = matrix.lineData[l].eqnend-matrix.lineData[l].eqnstart ;
      
      //      D[0] = 1./(D[0]<0.0?min(D[0],-1e-30):max(D[0],1e-30)) ;
      Dp[0] = 1./Dp[0] ;
      for(int i=1;i<lsz;++i) {
        real Dt = (Dp[i]-L[i-1]*Dp[i-1]*U[i-1]) ;
        Dp[i] = 1./(Dt<0.0?min<real>(Dt,-1e-30):max<real>(Dt,1e-30)) ;
      }
    }
    $LSGSscalarMatrix(X)->B.swap(B) ; 
    $LSGSscalarMatrix(X)->D.swap(D) ; 
    $LSGSscalarMatrix(X)->F.swap(F) ; 
    
  } ;

  $type LSGSScalarSolve(X)           store<real> ;


  $rule pointwise(LSGSScalarSolve(X)<-LSGSMaxIter,LSGSAbsTol,LSGSRelTol,
		  LSGSRelaxation, LSGSscalarMatrix(X),LSGSmatrixTopology(X)),
    option(disable_threading),prelude {
    struct matrixStructure & restrict matrix = matrixInfo[*$LSGSmatrixTopology(X)] ;
    // initialize x to zero
    vector<real> x1(matrix.eql2g.size(),0.0), xt(matrix.nmyeqn) ;

    real * X = &x1[0] ;
    vector<real> rhs(matrix.mxlinelen) ;

    for(size_t l=0;l<matrix.lineData.size();++l) { // loop over lines
      const real *L = &$LSGSscalarMatrix(X)->F[matrix.lineData[l].Lstart] ;
      const real *U = &$LSGSscalarMatrix(X)->F[matrix.lineData[l].Ustart] ;
      const real *D = &$LSGSscalarMatrix(X)->D[matrix.lineData[l].eqnstart] ;
      const real *B = &$LSGSscalarMatrix(X)->B[matrix.lineData[l].eqnstart] ;
      
      const int lsz = matrix.lineData[l].eqnend-matrix.lineData[l].eqnstart ;
      
      const int eqb = matrix.lineData[l].eqnstart ;

      // First compute rhs ;
      for(int i=0;i<lsz;++i)
        rhs[i] = B[i] ;

	real *restrict x = &X[eqb] ;
	// now solve line
	// forward solve 
	x[0] = rhs[0] ;
	for(int i=1;i<lsz;++i) {
	  x[i] = rhs[i] - L[i-1]*D[i-1]*x[i-1] ;
	}
	// backward solve
	x[lsz-1] = D[lsz-1]*x[lsz-1] ;
	for(int i=lsz-2;i>=0;--i) {
	  x[i] = D[i]*(x[i] - x[i+1]*U[i]) ;
	}
    }
    vector<real> send_data(matrix.send_entitiesl.size()) ;
    vector<real> recv_data(matrix.recv_entitiesl.size()) ;
    vector<MPI_Request> requests(matrix.recv_processors.size()) ;
    vector<MPI_Status> status(matrix.recv_processors.size()) ;

    real zero_resid = 1 ;
    real w = *$LSGSRelaxation ;
    int num_iter = *$LSGSMaxIter ;
    // do num_iter steps
    for(int iter = 0;iter < num_iter;++iter) {
      
      int psz = matrix.periodicCopy.size() ;
      for(int i=0;i<psz;++i)
        X[matrix.periodicCopy[i].first] = X[matrix.periodicCopy[i].second] ;
      if(iter == 0) {
        // copy send data for first iteration, aftwards the unrelaxed
        // values are copied later in the loop.
        for(size_t i=0;i<send_data.size();++i)
          send_data[i] = X[matrix.send_entitiesl[i]] ;
      }
      
      for(size_t i=0;i<matrix.recv_processors.size();++i) {
        int rs = matrix.recv_offsets[i] ;
        int re = matrix.recv_offsets[i+1] ;
        int rsz = re-rs ;
        int p = matrix.recv_processors[i] ;
        MPI_Irecv(&recv_data[rs],rsz,LSGS_TYPE,p,99,
                  MPI_COMM_WORLD,&requests[i]) ;
      }
      for(size_t i=0;i<matrix.send_processors.size();++i) {
        int ss = matrix.send_offsets[i] ;
        int se = matrix.send_offsets[i+1] ;
        int ssz = se-ss ;
        int p = matrix.send_processors[i] ;
        MPI_Send(&send_data[ss],ssz,LSGS_TYPE,p,99,MPI_COMM_WORLD) ;
      }
      MPI_Waitall(requests.size(),&requests[0],&status[0]) ;
      // copy recieved data 
      for(size_t i=0;i<recv_data.size();++i)
        X[matrix.recv_entitiesl[i]] = recv_data[i] ;
      for(int i=0;i<psz;++i)
        X[matrix.periodicCopy[i].first] = X[matrix.periodicCopy[i].second] ;
      


      // Forward sweep
      for(size_t l=0;l<matrix.lineData.size();++l) { // loop over lines
	const real *L = &$LSGSscalarMatrix(X)->F[matrix.lineData[l].Lstart] ;
	const real *U = &$LSGSscalarMatrix(X)->F[matrix.lineData[l].Ustart] ;
	const real *D = &$LSGSscalarMatrix(X)->D[matrix.lineData[l].eqnstart] ;
	const real *B = &$LSGSscalarMatrix(X)->B[matrix.lineData[l].eqnstart] ;
	const real *F = &$LSGSscalarMatrix(X)->F[0] ;

        const int ls = matrix.lineData[l].eqnstart ;
        const int le = matrix.lineData[l].eqnend ;

        for(int i=ls;i<le;++i)
          xt[i] = X[i] ;
        
	const int lsz = le-ls ;
	

	for(int i=0;i<lsz;++i) 
	  rhs[i] = B[i] ;


	const int   os = matrix.lineData[l].OuterStart ;
	const int   oe = matrix.lineData[l].OuterEnd ;
	for(int i=os;i<oe;++i) {
	  rhs[matrix.outerCLR[i].first-ls] 
	    -= X[matrix.outerCLR[i].second]*F[i] ;
	}
      
	real *restrict x = &X[ls] ;
	// now solve line
	// forward solve 
	x[0] = rhs[0] ;
	for(int i=1;i<lsz;++i) {
	  x[i] = rhs[i] - L[i-1]*D[i-1]*x[i-1] ;
	}
	// backward solve
	x[lsz-1] = D[lsz-1]*x[lsz-1] ;
	for(int i=lsz-2;i>=0;--i) {
	  x[i] = D[i]*(x[i] - x[i+1]*U[i]) ;
	}
      }

      // Backward sweep
      for(int l=matrix.lineData.size()-1;l>=0;--l) { // loop over lines
	const real *L = &$LSGSscalarMatrix(X)->F[matrix.lineData[l].Lstart] ;
	const real *U = &$LSGSscalarMatrix(X)->F[matrix.lineData[l].Ustart] ;
	const real *D = &$LSGSscalarMatrix(X)->D[matrix.lineData[l].eqnstart] ;
	const real *B = &$LSGSscalarMatrix(X)->B[matrix.lineData[l].eqnstart] ;
	const real *F = &$LSGSscalarMatrix(X)->F[0] ;

	const int lsz = matrix.lineData[l].eqnend-matrix.lineData[l].eqnstart ;

	const int ls = matrix.lineData[l].eqnstart ;

	// First compute rhs ;
	for(int i=0;i<lsz;++i)
	  rhs[i] = B[i] ;

	const int   os = matrix.lineData[l].OuterStart ;
	const int   oe = matrix.lineData[l].OuterEnd ;
	for(int i=os;i<oe;++i) {
	  rhs[matrix.outerCLR[i].first-ls] -= X[matrix.outerCLR[i].second]*F[i] ;
	}

	real *restrict x = &X[ls] ;
	// now solve line
	// forward solve 
	x[0] = rhs[0] ;
	for(int i=1;i<lsz;++i) {
	  x[i] = rhs[i] - L[i-1]*D[i-1]*x[i-1] ;
	}
	// backward solve
	x[lsz-1] = D[lsz-1]*x[lsz-1] ;
	for(int i=lsz-2;i>=0;--i) {
	  x[i] = D[i]*(x[i] - x[i+1]*U[i]) ;
	}
      }
      // copy data to send before relaxation
      for(size_t i=0;i<send_data.size();++i)
        send_data[i] = X[matrix.send_entitiesl[i]] ;

      // Relax update and compute current estimate for residual
      double residl = 0 ;
      for(int i=0;i<matrix.nmyeqn;++i) {
        X[i] = w*X[i] + (1.-w)*xt[i] ;
	double r = realToDouble(X[i]-xt[i]) ;
	residl += r*r ;
      }
      double resid = 0 ;
      MPI_Allreduce(&residl,&resid,1,MPI_DOUBLE,MPI_SUM,MPI_COMM_WORLD) ;
      resid = sqrt(resid) ;
      if(0 == iter)
	zero_resid = resid ;
      real rel_resid = resid/zero_resid ;
      //      if(Loci::MPI_rank == 0)
      //	cout << iter << ":sresid = " << rel_resid << endl ;
      if(rel_resid > 1.0)
	w *= 1./rel_resid ;

      if(resid < *$LSGSAbsTol) 
	break ;
      if(rel_resid < *$LSGSRelTol)
	break ;

      // Jacobi found to be not productive if unrelaxed values are communicated
#ifdef JACOBI
      // jacobi solve
      for(size_t l=0;l<matrix.lineData.size();++l) { // loop over lines
	const real *B = &$LSGSscalarMatrix(X)->B[matrix.lineData[l].eqnstart] ;
	const real *F = &$LSGSscalarMatrix(X)->F[0] ;

        const int ls = matrix.lineData[l].eqnstart ;
        const int le = matrix.lineData[l].eqnend ;

	const int lsz = le-ls ;
	
	real *restrict rhsl = &xt[ls] ;

	for(int i=0;i<lsz;++i) 
	  rhsl[i] = B[i] ;


	const int   os = matrix.lineData[l].OuterStart ;
	const int   oe = matrix.lineData[l].OuterEnd ;
	for(int i=os;i<oe;++i) {
	  rhsl[matrix.outerCLR[i].first-ls] 
	    -= X[matrix.outerCLR[i].second]*F[i] ;
	}
      }

      for(size_t l=0;l<matrix.lineData.size();++l) { // loop over lines
	const real *L = &$LSGSscalarMatrix(X)->F[matrix.lineData[l].Lstart] ;
	const real *U = &$LSGSscalarMatrix(X)->F[matrix.lineData[l].Ustart] ;
	const real *D = &$LSGSscalarMatrix(X)->D[matrix.lineData[l].eqnstart] ;
        const int ls = matrix.lineData[l].eqnstart ;
        const int le = matrix.lineData[l].eqnend ;

	const int lsz = le-ls ;
	real *restrict rhsl = &xt[matrix.lineData[l].eqnstart] ;
	real *restrict x = &X[ls] ;
	
	// now solve line
	// forward solve 
	x[0] = rhsl[0] ;
	for(int i=1;i<lsz;++i) {
	  x[i] = rhsl[i] - L[i-1]*D[i-1]*x[i-1] ;
	}
	// backward solve
	x[lsz-1] = D[lsz-1]*x[lsz-1] ;
	for(int i=lsz-2;i>=0;--i) {
	  x[i] = D[i]*(x[i] - x[i+1]*U[i]) ;
	}
      }
#endif
    }
    
    // copy data out
    for(int i=0;i<matrix.nmyeqn;++i) {
      $LSGSScalarSolve(X)[matrix.eql2g[i]] = x1[i] ; 
    }

  } ;
    

  // Blocked version
  $type X_D storeMat<real_fj> ;
  $type X_L storeMat<real_fj> ;
  $type X_U storeMat<real_fj> ;
  $type LSGSBlockedSSolve(X,B) storeVec<real> ;
  using flowPsi::tmp_array ;

  $rule pointwise(LSGSConnectivity(X)<-X_L,X_U),parametric(LSGSblockedMatrix(X)) {
    realF diagnorm = 0 ;
    for(int i=0;i<$*X_L.vecSize();++i) {
      diagnorm = max(diagnorm,max(fabs($X_L[i][i]),fabs($X_U[i][i]))) ;
    }
    $LSGSConnectivity(X) = diagnorm ;
  }


  class matrixHelpers: public Loci::CPTR_type {
  public:
    virtual void preprocessLine(real_fj *D, pivot_type *pivot,
				const real_fj *L, const real_fj *U, 
				int lsz, int vs) const = 0 ;
    virtual void linerhs(real *rhs, const real *X, const real_fj *B, 
			const pair<int,int> *CLR, const real_fj *F, 
			int ls, int le, int os, int oe, int vs) const = 0;
    virtual void lineSolve(real *X, const real *rhs, 
			   const real_fj *D, const pivot_type *pivot,
			   const real_fj *L, const real_fj *U, 
			   int lsz, int vs) const = 0 ;
    virtual real lineVerify(const real *X, const real *rhs, 
			      const real_fj *D, const pivot_type *pivot,
			      const real_fj *L, const real_fj *U, 
			      int lsz, int vs) const = 0 ;
  } ;

  class matrixHelpersGeneric: public matrixHelpers {
  public:
    virtual void preprocessLine(real_fj *D, pivot_type *pivot,
				const real_fj *L, const real_fj *U, 
				int lsz, int vs) const ;
    virtual void linerhs(real *rhs, const real *X, const real_fj *B, 
			const pair<int,int> *CLR, const real_fj *F, 
			int ls, int le, int os, int oe, int vs) const ;
    virtual void lineSolve(real *X, const real *rhs, 
			   const real_fj *D, const pivot_type *pivot,
			   const real_fj *L, const real_fj *U, 
			   int lsz, int vs) const ;
    virtual real lineVerify(const real *X, const real *rhs, 
			      const real_fj *D, const pivot_type *pivot,
			      const real_fj *L, const real_fj *U, 
			      int lsz, int vs) const ;
  } ;

  void matrixHelpersGeneric::
  preprocessLine(real_fj *restrict D, pivot_type *restrict pivot,
		 const real_fj *restrict L, 
		 const real_fj *restrict U, 
		 int lsz, int vs) const  {
    int vs2 = vs*vs ;

    Mat<real_fj> D0(D,vs) ;
    vector<real_fj> v(vs),t(vs) ;
    D0.decompose_lu_pivot(pivot) ;
    //    D0.decompose_lu() ;
    for(int i=1;i<lsz;++i) {
      const_Mat<real_fj> Dm(D,vs) ;
      D += vs2 ;
      Mat<real_fj> Dn(D,vs) ;
      const_Mat<real_fj> Lm(L,vs) ;
      const_Mat<real_fj> Um(U,vs) ;
      for(int j=0;j<vs;++j) { // Solve Dn -= Lm*Dm^-1*Um
	for(int k=0;k<vs;++k)
	  v[k] = Um[k][j] ;
	Dm.solve_lu_pivot(&v[0],&t[0],pivot) ;
	//	Dm.solve_lu(&v[0],&t[0]) ;
	for(int k=0;k<vs;++k)
	  v[k] = 0.0 ;
	Lm.dotprod_accum(&t[0],&v[0]) ;
	for(int k=0;k<vs;++k)
	  Dn[k][j] -= v[k] ;
      }
      pivot += vs ;
      Dn.decompose_lu_pivot(pivot) ;
      //      Dn.decompose_lu() ;
      L += vs2 ;
      U += vs2 ;
    }      
  }
  void matrixHelpersGeneric::
  linerhs(real *restrict rhs, const real *restrict X, const real_fj *restrict B,
	  const pair<int,int> *restrict CLR, const real_fj *restrict F, 
	 int ls, int le, int os, int oe, int vs) const {
    // note, here we compute the negative of the rhs, but we compensate
    // for this in the line solver.
    // also note, rhs computation in terms of equation number while
    // line solver starts with first element of line = 0
    for(int i=ls*vs;i<le*vs;++i)
      rhs[i] = -B[i] ;

    int vs2 = vs*vs ;
    //    F += os*vs2 ;
    //rhs[matrix.outerCLR[i].first-ls] += X[matrix.outerCLR[i].second]*F[i] ;
    for(int i=os;i<oe;++i) {
      const real * Xi   = &X[CLR[i].second*vs] ;
      real *       rhsi = &rhs[CLR[i].first*vs] ;
      const_Mat<real_fj> Fi(&F[i*vs2],vs) ;
      Fi.dotprod_accum(Xi,rhsi) ; // Add into rhs
			    //      F += vs2 ;
    }

  }




  void matrixHelpersGeneric::
  lineSolve(real *restrict X, const real *restrict rhs, 
	    const real_fj *restrict D, const pivot_type *restrict pivot,
	    const real_fj *restrict L, const real_fj *restrict U, 
	    int lsz, int vs) const {
    int vs2 = vs*vs ;
    vector<real> v(vs),t(vs) ;
    // forward solve part
      
    for(int i=0;i<vs;++i)
      X[i] = -rhs[i] ;
    int moffset = 0 ;
    int voffset = 0 ;
    for(int i=1;i<lsz;++i) {
      //   X[i] = L[i-1]*D[i-1]*rhs[i-1]- rhs[i] ;
      for(int j=0;j<vs;++j)
	X[voffset+vs+j] = -rhs[voffset+vs+j] ;
      const_Mat<real_fj> Dm(&D[moffset],vs) ;
      Dm.solve_lu_pivot(&X[voffset],&v[0],&pivot[voffset]) ;
      for(int j=0;j<vs;++j)
	v[j] = -v[j] ;
      //      Dm.solve_lu(&rhs[voffset],&v[0]) ;
      const_Mat<real_fj> Lm(&L[moffset],vs) ;
      Lm.dotprod_accum(&v[0],&X[voffset+vs]) ;
      
      moffset += vs2 ;
      voffset += vs ;
    }
    // backward solve
    voffset = (lsz-1)*vs ;
    moffset = (lsz-1)*vs2 ;
    const_Mat<real_fj> De(&D[moffset],vs) ;
    De.solve_lu_pivot(&X[voffset],&v[0],&pivot[voffset]) ;
    //De.solve_lu(&X[voffset],&v[0]) ;
    for(int i=0;i<vs;++i)
      X[voffset+i] = v[i] ;
    voffset -= vs ;
    moffset -= vs2 ;
    for(int i=lsz-2;i>=0;--i) {
      // solve X[i] = D[i]*(X[i]-X[i+1]*U[i]) 
      for(int j=0;j<vs;++j)
	v[j] = -X[voffset+j] ; // sign change so we can use dotprod_accum
      const_Mat<real_fj> Um(&U[moffset],vs) ;
      Um.dotprod_accum(&X[voffset+vs],&v[0]) ;
      const_Mat<real_fj> Dm(&D[moffset],vs) ;
      for(int j=0;j<vs;++j)
	v[j] = -v[j] ;
      Dm.solve_lu_pivot(&v[0],&X[voffset],&pivot[voffset]) ;
      //Dm.solve_lu(&v[0],&X[voffset]) ;
      voffset -= vs ;
      moffset -= vs2 ;
    }
  }

  real matrixHelpersGeneric::
  lineVerify(const real *X, const real *rhs, 
	     const real_fj *D, const pivot_type *pivot,
	     const real_fj *L, const real_fj *U, 
	     int lsz, int vs) const {
    int vs2 = vs*vs ;
    vector<real> sum(vs*lsz) ;
    real mxrhs = 0 ;
    for(int l=0;l<lsz;++l) {
      for(int i=0;i<vs;++i) {
	sum[l*vs+i] = rhs[l*vs+i] ;
	mxrhs = max(mxrhs,fabs(rhs[l*vs+i])) ;
      }
      const_Mat<real_fj> Di(&D[l*vs2],vs) ;
      Di.dotprod_accum(&X[l*vs],&sum[l*vs]) ;
    }
    for(int l=0;l<lsz-1;++l) {
      const_Mat<real_fj> Ul(&U[l*vs2],vs) ;
      Ul.dotprod_accum(&X[(l+1)*vs],&sum[l*vs]) ;
      const_Mat<real_fj> Ll(&L[l*vs2],vs) ;
      Ll.dotprod_accum(&X[l*vs],&sum[(l+1)*vs]) ;
    }
    real msq = 0 ;
    for(int i=0;i<vs*lsz;++i)
      msq += sum[i]*sum[i] ;

    if(mxrhs < 1e-30)
      return 0 ;
    return sqrt(msq)/mxrhs ;

  }

  struct blockedMatrixData {
    Loci::CPTR<matrixHelpers> matrixHelp ;
    int vs,vs2  ;
    vector<real_fj> B ;
    vector<real_fj> D ;
    vector<pivot_type> pivot ;
    //    vector<real_fj> Dreal ;
    vector<real_fj> F ;
  } ;
  struct blockedRHSData {
    vector<real_fj> B ;
  } ;

  $type LSGSblockedMatrix(X) blackbox<blockedMatrixData> ;

  $type LSGSblockedRHS(X,B) blackbox<blockedRHSData> ;

  $rule blackbox(LSGSblockedMatrix(X)<-LSGSmatrixTopology(X),
		 X_D,upper->X_U,lower->X_L), prelude {
    struct matrixStructure & restrict matrix = matrixInfo[*$LSGSmatrixTopology(X)] ;
    int vs = $X_D.vecSize() ;
    int vs2 = vs*vs ;
    $LSGSblockedMatrix(X)->vs = vs ;
    $LSGSblockedMatrix(X)->vs2 = vs2 ;
    $LSGSblockedMatrix(X)->matrixHelp = new matrixHelpersGeneric ;

    vector<real_fj> B(matrix.eql2g.size()*vs); 
    vector<real_fj> D(matrix.eql2g.size()*vs2); 
    //    vector<real_fj> Dreal(matrix.eql2g.size()*vs2); 
    vector<pivot_type> pivot(matrix.eql2g.size()*vs) ; 
    vector<real_fj> F(matrix.outerCLR.size()*vs2); 
    
    // Copy matrix into data structure
    for(int i=0;i<matrix.nmyeqn;++i) {
      int eqn = matrix.eql2g[i] ;
      const real_fj *restrict Dp = &($X_D[eqn][0][0]) ;
      for(int j=0;j<vs2;++j) 
	D[i*vs2+j] = Dp[j] ;
      //      for(int j=0;j<vs2;++j) 
      //	Dreal[i*vs2+j] = Dp[j] ;
    }
    entitySet ldom  = matrix.globalL2l.domain() ;
    FORALL(ldom,ii) {
      const real_fj *restrict Lp = &($X_L[ii][0][0]) ;
      int Findex = matrix.globalL2l[ii]*vs2 ;
      for(int j=0;j<vs2;++j) 
	F[Findex+j] = Lp[j] ;
    } ENDFORALL ;
    entitySet udom  = matrix.globalU2l.domain() ;
    FORALL(udom,ii) {
      const real_fj *restrict Up = &($X_U[ii][0][0]) ;
      int Findex = matrix.globalU2l[ii]*vs2 ;
      for(int j=0;j<vs2;++j) 
	F[Findex+j] = Up[j] ;
    } ENDFORALL ;

    int nlines = matrix.lineData.size() ;
    // Preprocess lines (recompute diagonal term)
    for(int l=0;l<nlines;++l) { // loop over lines
      int lsz =  matrix.lineData[l].eqnend-matrix.lineData[l].eqnstart ;
      const real_fj *L = &F[matrix.lineData[l].Lstart*vs2] ;
      const real_fj *U = &F[matrix.lineData[l].Ustart*vs2] ;
      real_fj * Dp = &D[matrix.lineData[l].eqnstart*vs2] ;
      pivot_type * pv = &pivot[matrix.lineData[l].eqnstart*vs] ;

      $LSGSblockedMatrix(X)->matrixHelp
	->preprocessLine(Dp,pv,L,U,lsz,vs) ;
    }

    $LSGSblockedMatrix(X)->B.swap(B) ; 
    $LSGSblockedMatrix(X)->D.swap(D) ; 
    $LSGSblockedMatrix(X)->pivot.swap(pivot) ;
    $LSGSblockedMatrix(X)->F.swap(F) ; 
    //    $LSGSblockedMatrix(X)->Dreal.swap(Dreal) ; 
  } ;

  $type B storeVec<real_fj> ;
  $rule blackbox(LSGSblockedRHS(X,B)<-LSGSmatrixTopology(X),B),prelude {
    struct matrixStructure & restrict matrix = matrixInfo[*$LSGSmatrixTopology(X)] ;
    int vs = $B.vecSize() ;
    vector<real_fj> B(matrix.nmyeqn*vs); 
    
    // Copy matrix into data structure
    for(int i=0;i<matrix.nmyeqn;++i) {
      int eqn = matrix.eql2g[i] ;
      const real_fj *restrict Bp = &($B[eqn][0]) ;
      for(int j=0;j<vs;++j) 
	B[i*vs+j] = Bp[j] ;
    }
    $LSGSblockedRHS(X,B)->B.swap(B) ; 
  } ;

  $rule pointwise(LSGSBlockedSSolve(X,B)<- LSGSMaxIter,LSGSAbsTol,LSGSRelTol,
		  LSGSRelaxation,LSGSblockedMatrix(X),LSGSblockedRHS(X,B),
		  LSGSmatrixTopology(X)),
    option(disable_threading),
    prelude {
    struct matrixStructure & restrict matrix = matrixInfo[*$LSGSmatrixTopology(X)] ;
    int vs = $LSGSblockedMatrix(X)->vs ;
    $LSGSBlockedSSolve(X,B).setVecSize(vs) ;
    int vs2 = vs*vs ;
    int vsize = matrix.eql2g.size() ;
    vector<real> x1(vsize*vs) , xt(matrix.nmyeqn*vs) ;
    
    real *X = &x1[0] ;
    
    vector<real> rhs(matrix.mxlinelen*vs) ;
    real zero_resid =1;
    // jacobi initializes iteration
    for(size_t l=0;l<matrix.lineData.size();++l) { // loop over lines
      const real_fj *B = &($LSGSblockedRHS(X,B)->B[0]) ;
      int ls = matrix.lineData[l].eqnstart ;
      int le = matrix.lineData[l].eqnend ;

      real * rhsg = &rhs[0] - ls*vs ; 
      for(int i=ls*vs;i<le*vs;++i)
	rhsg[i] = -B[i] ;

      const real_fj *D = &($LSGSblockedMatrix(X)->D[ls*vs2]) ;
      const pivot_type *pivot = &($LSGSblockedMatrix(X)->pivot[ls*vs]) ;
      const real_fj *L = &$LSGSblockedMatrix(X)->F[matrix.lineData[l].Lstart*vs2] ;
      const real_fj *U = &$LSGSblockedMatrix(X)->F[matrix.lineData[l].Ustart*vs2] ;
      int lsz = le-ls ;
      $LSGSblockedMatrix(X)->matrixHelp
	->lineSolve(X+ls*vs,&rhs[0],D,pivot,L,U,lsz,vs) ;
      //      const real_fj *Dr = &($LSGSblockedMatrix(X)->Dreal[ls*vs2]) ;
      //      real err = $LSGSblockedMatrix(X)->matrixHelp
      //      	->lineVerify(X+ls*vs,&rhs[0],Dr,pivot,L,U,lsz,vs) ;
      //      cout << "l=" << l << ",err = " << err << ",lsz =" << lsz<< endl ;
    }

    vector<real> send_data(matrix.send_entitiesl.size()*vs) ;
    vector<real> recv_data(matrix.recv_entitiesl.size()*vs) ;
    vector<MPI_Request> requests(matrix.recv_processors.size()+matrix.send_processors.size()) ;
    vector<MPI_Status> status(matrix.recv_processors.size()+matrix.send_processors.size()) ;
    int num_iter = *$LSGSMaxIter ;
    real w = *$LSGSRelaxation ;

    // Entry communication 
    for(int iter = 0;iter<num_iter;++iter) {
      // copy send data 
      int psz = matrix.periodicCopy.size() ;
      if(iter == 0) {
        for(int i=0;i<psz;++i) {
          for(int j=0;j<vs;++j) {
            X[matrix.periodicCopy[i].first*vs+j] = X[matrix.periodicCopy[i].second*vs+j] ;
          }
        }
        for(size_t i=0;i<matrix.send_entitiesl.size();++i) {
          int loc = matrix.send_entitiesl[i]*vs ;
          int ii = i*vs ;
          for(int j=0;j<vs;++j)
            send_data[ii+j] = X[loc+j] ;
        }
        for(size_t i=0;i<matrix.recv_processors.size();++i) {
          int rs = matrix.recv_offsets[i]*vs ;
          int re = matrix.recv_offsets[i+1]*vs ;
          int rsz = re-rs ;
          int p = matrix.recv_processors[i] ;
          MPI_Irecv(&recv_data[rs],rsz,LSGS_TYPE,p,99,
                    MPI_COMM_WORLD,&requests[i]) ;
        }

        int rpsz = matrix.recv_processors.size() ;
        
        for(size_t i=0;i<matrix.send_processors.size();++i) {
          int ss = matrix.send_offsets[i]*vs ;
          int se = matrix.send_offsets[i+1]*vs ;
          int ssz = se-ss ;
          int p = matrix.send_processors[i] ;
          MPI_Isend(&send_data[ss],ssz,LSGS_TYPE,p,99,MPI_COMM_WORLD,
                    &requests[i+rpsz]) ;
        }
        MPI_Waitall(requests.size(),&requests[0],&status[0]) ;
        // copy recieved data 
        for(size_t i=0;i<matrix.recv_entitiesl.size();++i) {
          int loc = matrix.recv_entitiesl[i]*vs ;
          int ii = i*vs ;
          for(int j=0;j<vs;++j)
            X[loc+j] = recv_data[ii+j] ;
        }
      }
      for(int i=0;i<psz;++i) {
        for(int j=0;j<vs;++j) {
          X[matrix.periodicCopy[i].first*vs+j] = X[matrix.periodicCopy[i].second*vs+j] ;
        }
      }

      // Forward sweep
      for(size_t l=0;l<matrix.lineData.size();++l) { // loop over lines
	const real_fj *B = &($LSGSblockedRHS(X,B)->B[0]) ;
	const real_fj *F = &($LSGSblockedMatrix(X)->F[0]) ;
	const pair<int,int> *CLR = &(matrix.outerCLR[0]) ;
	int ls = matrix.lineData[l].eqnstart ;
	int le = matrix.lineData[l].eqnend ;
	int os = matrix.lineData[l].OuterStart ;
	int oe = matrix.lineData[l].OuterEnd ;
	real *restrict rhsg = &rhs[0] - ls*vs ; 
	$LSGSblockedMatrix(X)->matrixHelp
	  ->linerhs(rhsg,&X[0],B,CLR,F,ls,le,os,oe,vs) ;

	const real_fj *D = &($LSGSblockedMatrix(X)->D[ls*vs2]) ;
	const pivot_type *pivot = &($LSGSblockedMatrix(X)->pivot[ls*vs]) ;
	const real_fj *L = &$LSGSblockedMatrix(X)->F[matrix.lineData[l].Lstart*vs2] ;
	const real_fj *U = &$LSGSblockedMatrix(X)->F[matrix.lineData[l].Ustart*vs2] ;
	int lsz = le-ls ;
	for(int i=ls*vs;i<le*vs;++i)
	  xt[i] = X[i] ;

	$LSGSblockedMatrix(X)->matrixHelp
	  ->lineSolve(X+ls*vs,&rhs[0],D,pivot,L,U,lsz,vs) ;
      }

      // Backward sweep
      for(int l=matrix.lineData.size()-1;l>=0;--l) { // loop over lines
	const real_fj *B = &($LSGSblockedRHS(X,B)->B[0]) ;
	const real_fj *F = &($LSGSblockedMatrix(X)->F[0]) ;
	const pair<int,int> *CLR = &(matrix.outerCLR[0]) ;
	int ls = matrix.lineData[l].eqnstart ;
	int le = matrix.lineData[l].eqnend ;
	int os = matrix.lineData[l].OuterStart ;
	int oe = matrix.lineData[l].OuterEnd ;
	real * rhsg = &rhs[0] - ls*vs ; 
	$LSGSblockedMatrix(X)->matrixHelp
	  ->linerhs(rhsg,X,B,CLR,F,ls,le,os,oe,vs) ;

	const real_fj *D = &($LSGSblockedMatrix(X)->D[ls*vs2]) ;
	const pivot_type *pivot = &($LSGSblockedMatrix(X)->pivot[ls*vs]) ;
	const real_fj *L = &$LSGSblockedMatrix(X)->F[matrix.lineData[l].Lstart*vs2] ;
	const real_fj *U = &$LSGSblockedMatrix(X)->F[matrix.lineData[l].Ustart*vs2] ;
	int lsz = le-ls ;
	for(int i=ls*vs;i<le*vs;++i)
	  xt[i] = X[i] ;
	$LSGSblockedMatrix(X)->matrixHelp
	  ->lineSolve(X+ls*vs,&rhs[0],D,pivot,L,U,lsz,vs) ;
      }
      
      // Copy data for communication
      for(int i=0;i<psz;++i) {
        for(int j=0;j<vs;++j) {
          X[matrix.periodicCopy[i].first*vs+j] = X[matrix.periodicCopy[i].second*vs+j] ;
        }
      }
      for(size_t i=0;i<matrix.send_entitiesl.size();++i) {
        int loc = matrix.send_entitiesl[i]*vs ;
        int ii = i*vs ;
        for(int j=0;j<vs;++j)
          send_data[ii+j] = X[loc+j] ;
      }
      
      // Initiate interprocessor communication
      for(size_t i=0;i<matrix.recv_processors.size();++i) {
        int rs = matrix.recv_offsets[i]*vs ;
        int re = matrix.recv_offsets[i+1]*vs ;
        int rsz = re-rs ;
        int p = matrix.recv_processors[i] ;
        MPI_Irecv(&recv_data[rs],rsz,LSGS_TYPE,p,99,
                  MPI_COMM_WORLD,&requests[i]) ;
      }

      int rpsz = matrix.recv_processors.size() ;
        
      for(size_t i=0;i<matrix.send_processors.size();++i) {
        int ss = matrix.send_offsets[i]*vs ;
        int se = matrix.send_offsets[i+1]*vs ;
        int ssz = se-ss ;
        int p = matrix.send_processors[i] ;
        MPI_Isend(&send_data[ss],ssz,LSGS_TYPE,p,99,MPI_COMM_WORLD,
                  &requests[i+rpsz]) ;
      }

      // Compute residual
      double residl = 0 ;
      for(int i=0;i<matrix.nmyeqn*vs;++i) {
	X[i] = w*X[i] + (1.-w)*xt[i] ;
	double r = realToDouble(X[i]-xt[i]) ;
	residl += r*r ;
      }

      // Doing a jacobi here seems like a good idea, but in practice it
      // doesn't seem to help enough to justify its cost.
      //#define JACOBI
#ifdef JACOBI
      // line jacobi after relaxed GSI
      // Compute rhs for all lines (Use xt for storage)
      for(int l=matrix.lineData.size()-1;l>=0;--l) { // loop over lines
	const real_fj *B = &($LSGSblockedRHS(X,B)->B[0]) ;
	const real_fj *F = &($LSGSblockedMatrix(X)->F[0]) ;
	const pair<int,int> *CLR = &(matrix.outerCLR[0]) ;
	int ls = matrix.lineData[l].eqnstart ;
	int le = matrix.lineData[l].eqnend ;
	int os = matrix.lineData[l].OuterStart ;
	int oe = matrix.lineData[l].OuterEnd ;
	real * rhsg = &xt[0] ;
	$LSGSblockedMatrix(X)->matrixHelp
	  ->linerhs(rhsg,X,B,CLR,F,ls,le,os,oe,vs) ;

      }
      // update lines
      for(int l=matrix.lineData.size()-1;l>=0;--l) { // loop over lines
	int ls = matrix.lineData[l].eqnstart ;
	int le = matrix.lineData[l].eqnend ;

	const real_fj *D = &($LSGSblockedMatrix(X)->D[ls*vs2]) ;
	const pivot_type *pivot = &($LSGSblockedMatrix(X)->pivot[ls*vs]) ;
	const real_fj *L = &$LSGSblockedMatrix(X)->F[matrix.lineData[l].Lstart*vs2] ;
	const real_fj *U = &$LSGSblockedMatrix(X)->F[matrix.lineData[l].Ustart*vs2] ;
	int lsz = le-ls ;
	const real *rhsl = &xt[ls*vs] ;
	$LSGSblockedMatrix(X)->matrixHelp
	  ->lineSolve(X+ls*vs,rhsl,D,pivot,L,U,lsz,vs) ;
      }
#endif
      
      // Finish communication after local line solve
      MPI_Waitall(requests.size(),&requests[0],&status[0]) ;
      // copy recieved data 
      for(size_t i=0;i<matrix.recv_entitiesl.size();++i) {
        int loc = matrix.recv_entitiesl[i]*vs ;
        int ii = i*vs ;
        for(int j=0;j<vs;++j)
          X[loc+j] = recv_data[ii+j] ;
      }

      for(int i=0;i<psz;++i) {
        for(int j=0;j<vs;++j) {
          X[matrix.periodicCopy[i].first*vs+j] = X[matrix.periodicCopy[i].second*vs+j] ;
        }
      }

      // Check residual
      double resid = 0 ;
      MPI_Allreduce(&residl,&resid,1,MPI_DOUBLE,MPI_SUM,MPI_COMM_WORLD) ;
      resid = sqrt(resid) ;
      if(0 == iter)
	zero_resid = resid ;
      real rel_resid = resid/zero_resid ;
      //      if(Loci::MPI_rank == 0)
      //	cout << iter << ":resid = " << rel_resid << endl ;
      if(rel_resid > 1.0)
	w *= 1./rel_resid ;
      if(resid < *$LSGSAbsTol) 
	break ;
      if(rel_resid < *$LSGSRelTol)
	break ;
      
    }
    for(int i=0;i<matrix.nmyeqn;++i) {
      for(int j=0;j<vs;++j)
	$LSGSBlockedSSolve(X,B)[matrix.eql2g[i]][j] = X[i*vs+j] ;
    }
  } ;

  

  $type LSGSPreconSteps param<int> ;
  $rule default(LSGSPreconSteps) {
    $LSGSPreconSteps = 3 ;
  }
  

  $type LSGSPreconditioner(X,B) storeVec<real> ;
  $rule pointwise(LSGSPreconditioner(X,B)<- LSGSPreconSteps,
		  LSGSRelaxation,LSGSblockedMatrix(X),LSGSblockedRHS(X,B),
		  LSGSmatrixTopology(X)),
    option(disable_threading),
    prelude {
    struct matrixStructure & restrict matrix = matrixInfo[*$LSGSmatrixTopology(X)] ;
    int vs = $LSGSblockedMatrix(X)->vs ;
    $LSGSPreconditioner(X,B).setVecSize(vs) ;
    int vs2 = vs*vs ;
    int vsize = matrix.eql2g.size() ;
    vector<real> x1(vsize*vs) , xt(matrix.nmyeqn*vs) ;
    
    real *X = &x1[0] ;
    
    vector<real> rhs(matrix.mxlinelen*vs) ;
    // jacobi initializes iteration
    for(size_t l=0;l<matrix.lineData.size();++l) { // loop over lines
      const real_fj *B = &($LSGSblockedRHS(X,B)->B[0]) ;
      int ls = matrix.lineData[l].eqnstart ;
      int le = matrix.lineData[l].eqnend ;

      real * rhsg = &rhs[0] - ls*vs ; 
      for(int i=ls*vs;i<le*vs;++i)
	rhsg[i] = -B[i] ;

      const real_fj *D = &($LSGSblockedMatrix(X)->D[ls*vs2]) ;
      const pivot_type *pivot = &($LSGSblockedMatrix(X)->pivot[ls*vs]) ;
      const real_fj *L = &$LSGSblockedMatrix(X)->F[matrix.lineData[l].Lstart*vs2] ;
      const real_fj *U = &$LSGSblockedMatrix(X)->F[matrix.lineData[l].Ustart*vs2] ;
      int lsz = le-ls ;
      $LSGSblockedMatrix(X)->matrixHelp
	->lineSolve(X+ls*vs,&rhs[0],D,pivot,L,U,lsz,vs) ;
      //      const real_fj *Dr = &($LSGSblockedMatrix(X)->Dreal[ls*vs2]) ;
      //      real err = $LSGSblockedMatrix(X)->matrixHelp
      //      	->lineVerify(X+ls*vs,&rhs[0],Dr,pivot,L,U,lsz,vs) ;
      //      cout << "l=" << l << ",err = " << err << ",lsz =" << lsz<< endl ;
    }

    vector<real> send_data(matrix.send_entitiesl.size()*vs) ;
    vector<real> recv_data(matrix.recv_entitiesl.size()*vs) ;
    vector<MPI_Request> requests(matrix.recv_processors.size()) ;
    vector<MPI_Status> status(matrix.recv_processors.size()) ;
    int num_iter = *$LSGSPreconSteps ;
    real w = *$LSGSRelaxation ;
    for(int iter = 0;iter<num_iter;++iter) {
      // Forward sweep
      for(size_t l=0;l<matrix.lineData.size();++l) { // loop over lines
	const real_fj *B = &($LSGSblockedRHS(X,B)->B[0]) ;
	const real_fj *F = &($LSGSblockedMatrix(X)->F[0]) ;
	const pair<int,int> *CLR = &(matrix.outerCLR[0]) ;
	int ls = matrix.lineData[l].eqnstart ;
	int le = matrix.lineData[l].eqnend ;
	int os = matrix.lineData[l].OuterStart ;
	int oe = matrix.lineData[l].OuterEnd ;
	real *restrict rhsg = &rhs[0] - ls*vs ; 
	$LSGSblockedMatrix(X)->matrixHelp
	  ->linerhs(rhsg,&X[0],B,CLR,F,ls,le,os,oe,vs) ;

	const real_fj *D = &($LSGSblockedMatrix(X)->D[ls*vs2]) ;
	const pivot_type *pivot = &($LSGSblockedMatrix(X)->pivot[ls*vs]) ;
	const real_fj *L = &$LSGSblockedMatrix(X)->F[matrix.lineData[l].Lstart*vs2] ;
	const real_fj *U = &$LSGSblockedMatrix(X)->F[matrix.lineData[l].Ustart*vs2] ;
	int lsz = le-ls ;
	for(int i=ls*vs;i<le*vs;++i)
	  xt[i] = X[i] ;

	$LSGSblockedMatrix(X)->matrixHelp
	  ->lineSolve(X+ls*vs,&rhs[0],D,pivot,L,U,lsz,vs) ;
      }

      // Backward sweep
      for(int l=matrix.lineData.size()-1;l>=0;--l) { // loop over lines
	const real_fj *B = &($LSGSblockedRHS(X,B)->B[0]) ;
	const real_fj *F = &($LSGSblockedMatrix(X)->F[0]) ;
	const pair<int,int> *CLR = &(matrix.outerCLR[0]) ;
	int ls = matrix.lineData[l].eqnstart ;
	int le = matrix.lineData[l].eqnend ;
	int os = matrix.lineData[l].OuterStart ;
	int oe = matrix.lineData[l].OuterEnd ;
	real * rhsg = &rhs[0] - ls*vs ; 
	$LSGSblockedMatrix(X)->matrixHelp
	  ->linerhs(rhsg,X,B,CLR,F,ls,le,os,oe,vs) ;

	const real_fj *D = &($LSGSblockedMatrix(X)->D[ls*vs2]) ;
	const pivot_type *pivot = &($LSGSblockedMatrix(X)->pivot[ls*vs]) ;
	const real_fj *L = &$LSGSblockedMatrix(X)->F[matrix.lineData[l].Lstart*vs2] ;
	const real_fj *U = &$LSGSblockedMatrix(X)->F[matrix.lineData[l].Ustart*vs2] ;
	int lsz = le-ls ;
	for(int i=ls*vs;i<le*vs;++i)
	  xt[i] = X[i] ;
	$LSGSblockedMatrix(X)->matrixHelp
	  ->lineSolve(X+ls*vs,&rhs[0],D,pivot,L,U,lsz,vs) ;
      }
      for(int i=0;i<matrix.nmyeqn*vs;++i) {
	X[i] = w*X[i] + (1.-w)*xt[i] ;
      }
    }
    for(int i=0;i<matrix.nmyeqn;++i) {
      for(int j=0;j<vs;++j)
	$LSGSPreconditioner(X,B)[matrix.eql2g[i]][j] = X[i*vs+j] ;
    }
  } ;
  

}
