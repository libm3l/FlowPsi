//#############################################################################
//#
//# Copyright 2015, Adam Jirasek
//#
//# This file is part of the flowPsi computational fluid dynamics solver.
//#
//# The flowPsi solver is free software: you can redistribute it and/or modify
//# it under the terms of the GNU General Public License as published by
//# the Free Software Foundation, either version 3 of the License, or
//# (at your option) any later version.
//#
//# The flowPsi solver is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# GNU General Public License for more details.
//#
//# You should have received a copy of the GNU General Public License
//# along with the flowPsi solver.  If not, see <http://www.gnu.org/licenses>
//#
//#############################################################################




/*
 * 
 * Description: calculates gust and adds it to the grid velocity
 *
 * CHANGELOG:
 * Version   Author:               Date       Patch number  CLA     Comment
 * -------   -------               --------   --------      ---     -------
 * 1-beta-6  Adam Jirasek         2018-03-21                        Initial Implementation
 *
 *
 *
 * 
 */

#include <Loci.h>
#include <Tools/tools.h>
#include <iostream>
#include <fstream>
#include <string>

using std::string ;
using std::endl ;
using std::cout ;
using std::cerr ;
using std::ifstream ;
using std::ios ;

#include <vector>
using std::vector ;
#include <map>
using std::map ;
#include <set>
using std::set ;

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

$include "flowPsi.lh"

namespace flowPsi {

  $type Gust store<bool> ;  
  
//  $rule default(Gust){
//    $Gust = false ;      
//  }
  
//  $rule pointwise(Gust),constraint(componentGust) {
//    $Gust = true ;
//  }
/*
 * add artificial velocity due to 1-cos gust to face velocity
 */
  $rule apply(us_n<-dtmax,stime,area,facecenter)[Loci::Summation],constraint(area){

    real time = $dtmax + $stime;
    
   // std::cout << "UREF is     0000000000000000000000000       " << $uRef << endl ;
/*
 *  transformation matrix 
 *    direction of gust propagation
 *    direction normal to gust plane
 *    direction of gust disturbance 
 */
    real length = 61.24727674;
    real velfree = 102.078794566 ;

    vect3d tm1 = vect3d(1.0, 0.0, 0.0);
    vect3d tm2 = vect3d(0.0, 1.0, 0.0);

    real n1,n2,n3;
    n1 = tm1.y*tm2.z-tm1.z*tm2.y;
    n2 =-tm1.x*tm2.z+tm1.z*tm2.x;
    n3 = tm1.x*tm2.y-tm1.y*tm2.x;
    vect3d tm3 = vect3d(n1, n2, n3);

    vect3d tmn1 = vect3d(tm1.x, tm2.x, tm3.x);

    vect3d usv;

    vect3d gust_orig = vect3d(-1.0, 0.0, 0.0);
    real twopil = 3.1415926 / length ;  // length is so called gradient length
/*
 * interpolate
 */
    real xmin    = velfree * time - 2*length;
    real xmax    = velfree * time;

    real xtmp = (tmn1.x * ($facecenter.x-gust_orig.x)) +
                        (tmn1.y * ($facecenter.y-gust_orig.y)) +
                        (tmn1.z * ($facecenter.z-gust_orig.z));

    if(  (xtmp > xmin ) && (xtmp < xmax)){
       real gvel  = 3 * (1 - cos(twopil * (xmax - xtmp) ))/2.;
       usv.x = tm3.x * gvel;
       usv.y = tm3.y * gvel;
       usv.z = tm3.z * gvel;
    }else{
       usv = vect3d(0.0, 0.0, 0.0);
    }

    $us_n = -dot(usv,$area.n);
  };

}
