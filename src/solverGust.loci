//#############################################################################
//#
//# Copyright 2015, Adam Jirasek
//#
//# This file is part of the flowPsi computational fluid dynamics solver.
//#
//# The flowPsi solver is free software: you can redistribute it and/or modify
//# it under the terms of the GNU General Public License as published by
//# the Free Software Foundation, either version 3 of the License, or
//# (at your option) any later version.
//#
//# The flowPsi solver is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# GNU General Public License for more details.
//#
//# You should have received a copy of the GNU General Public License
//# along with the flowPsi solver.  If not, see <http://www.gnu.org/licenses>
//#
//#############################################################################




/*
 * 
 * Description: calculates gust and adds it to the grid velocity
 *
 * CHANGELOG:
 * Version   Author:               Date       Patch number  CLA     Comment
 * -------   -------               --------   --------      ---     -------
 * 1-beta-6  Adam Jirasek         2018-03-21                        Initial Implementation
 *
 *
 *
 * 
 */

#include <Loci.h>
$include "flowPsi.lh"
#include <Tools/tools.h>
#include <iostream>
#include <fstream>
#include <string>

using std::string ;
using std::endl ;
using std::cout ;
using std::cerr ;
using std::ifstream ;
using std::ios ;

#include <vector>
using std::vector ;
#include <map>
using std::map ;
#include <set>
using std::set ;

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

$include "flowPsi.lh"

namespace flowPsi {

  $rule optional(gustSpecification) {}

  $type Gust store<bool> ;
/*
 * set gust types
 */
  $type GustTypes blackbox<std::set<std::string> > ;

  $rule unit(GustTypes<-gustSpecification),prelude {
    *$GustTypes = std::set<std::string>() ;
  } ;

  $rule apply(GustTypes)[Loci::NullOp],
    constraint(UNIVERSE),prelude {
    $GustTypes->insert(string("oneMcos")) ;
    $GustTypes->insert(string("step")) ;
    $GustTypes->insert(string("pulse")) ;
    $GustTypes->insert(string("prescribed")) ;
  } ;
/*
 * specify constraints for each type of gust
 * gust is specified in entire domain, not per
 * volumeTag
 */ 
  $type GustTypes_oneMcos Constraint ;
  $type GustTypes_step Constraint ;
  $type GustTypes_pulse Constraint ;
  $type GustTypes_prescribed Constraint ;
/*
 * set the proper gust type
 */
  $rule constraint(GustTypes_oneMcos,GustTypes_step,GustTypes_pulse,GustTypes_prescribed<-gustSpecification,GustTypes){

    $GustTypes_oneMcos    = EMPTY ;
    $GustTypes_step       = EMPTY ;
    $GustTypes_pulse      = EMPTY ;
    $GustTypes_prescribed = EMPTY ;

    string type;

    Loci::options_list int_info ;
    int_info  = $gustSpecification;
    int_info.getOption("type",type) ;
        
    if(type == "oneMcos") {
      $GustTypes_oneMcos = ~EMPTY ;
    } else if(type == "step") {
      $GustTypes_step = ~EMPTY ;
    } else if(type == "pulse") {
      $GustTypes_pulse = ~EMPTY ;
    } else if(type == "prescribed") {
      $GustTypes_prescribed = ~EMPTY ;
    } else {
      cerr << "Unknown gust type '" << type << "'" << endl ;
      Loci::Abort() ;
    }
  };

/*
 * if required, set that gust will be computed
 */  
  $rule pointwise(Gust),constraint(gustSpecification) {
    $Gust = true ;
  }

/*
 * add artificial velocity due to 1-cos gust to face velocity
 */
  $rule apply(us_n<-dtmax,stime,area,facecenter)[Loci::Summation],constraint(area,GustTypes_oneMcos){

    real time = $dtmax + $stime;
    
   // std::cout << "UREF is     0000000000000000000000000       " << $uRef << endl ;
/*
 *  transformation matrix 
 *    direction of gust propagation
 *    direction normal to gust plane
 *    direction of gust disturbance 
 */
   real length = 61.24727674;
   real velfree = 102.078794566 ;
 //   real length =  102.078794566;
 //   real velfree = 170.131324276 ;

 //   real length =  20.415758913;
 //   real velfree = 34.026264855;

    vect3d tm1 = vect3d(1.0, 0.0, 0.0);
    vect3d tm2 = vect3d(0.0, 1.0, 0.0);

    real n1,n2,n3;
    n1 = tm1.y*tm2.z-tm1.z*tm2.y;
    n2 =-tm1.x*tm2.z+tm1.z*tm2.x;
    n3 = tm1.x*tm2.y-tm1.y*tm2.x;
    vect3d tm3 = vect3d(n1, n2, n3);

    vect3d tmn1 = vect3d(tm1.x, tm2.x, tm3.x);

    vect3d usv;

    vect3d gust_orig = vect3d(-1.0, 0.0, 0.0);
    real twopil = 3.1415926 / length ;  // length is so called gradient length
/*
 * interpolate
 */
    real xmin    = velfree * time - 2*length;
    real xmax    = velfree * time;

    real xtmp = (tmn1.x * ($facecenter.x-gust_orig.x)) +
                        (tmn1.y * ($facecenter.y-gust_orig.y)) +
                        (tmn1.z * ($facecenter.z-gust_orig.z));

    if(  (xtmp > xmin ) && (xtmp < xmax)){
       real gvel  = 3 * (1 - cos(twopil * (xmax - xtmp) ))/2.;
       usv.x = tm3.x * gvel;
       usv.y = tm3.y * gvel;
       usv.z = tm3.z * gvel;
    }else{
       usv = vect3d(0.0, 0.0, 0.0);
    }

    $us_n = -dot(usv,$area.n);
  };

}
