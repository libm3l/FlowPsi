//#############################################################################
//#
//# Copyright 2018, Adam Jirasek
//#
//# This file is part of the flowPsi computational fluid dynamics solver.
//#
//# The flowPsi solver is free software: you can redistribute it and/or modify
//# it under the terms of the GNU General Public License as published by
//# the Free Software Foundation, either version 3 of the License, or
//# (at your option) any later version.
//#
//# The flowPsi solver is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# GNU General Public License for more details.
//#
//# You should have received a copy of the GNU General Public License
//# along with the flowPsi solver.  If not, see <http://www.gnu.org/licenses>
//#
//#############################################################################




/*
 * 
 * Description: calculates gust and adds it to the grid velocity
 *
 * CHANGELOG:
 * Version   Author:               Date       Patch number  CLA     Comment
 * -------   -------               --------   --------      ---     -------
 * 1-beta-6  Adam Jirasek         2018-03-21                     Initial Implementation
 *                                                              of 1-cos and pulse gust
 *
 *
 *
 * 
 */

#include <Loci.h>
$include "flowPsi.lh"
#include <Tools/tools.h>
#include <iostream>
#include <fstream>
#include <string>

using std::string ;
using std::endl ;
using std::cout ;
using std::cerr ;
using std::ifstream ;
using std::ios ;

#include <vector>
using std::vector ;
#include <map>
using std::map ;
#include <set>
using std::set ;

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

$include "flowPsi.lh"

namespace flowPsi {

  $rule optional(gustSpecification) {}

  $type Gust param<bool>;
  $type tmn1 param<vect3d>;
  $type tm3  param<vect3d>;

  $type Usg    param<real>;
  $type gnorm  param<vect3d>;
  $type gvel   param<vect3d>;
  $type Lgrad  param<real>;
  $type Gvel   param<real>;
  $type Ogust  param<vect3d>;
/*
 * if required, set that gust will be computed
 */  
  $rule singleton(Gust),constraint(gustSpecification) {
    $Gust = true ;
  }

  $rule singleton(tm3<-gvel,gnorm), constraint(Gust) {
/*
 *  transformation matrix 
 *    direction of gust propagation
 *    direction normal to gust plane
 *    direction of gust disturbance 
 */
    vect3d tm1 = $gvel;   //vect3d(1.0, 0.0, 0.0);
    vect3d tm2 = $gnorm;  //vect3d(0.0, 1.0, 0.0); 
    real n1,n2,n3,nl;

    nl = sqrt(tm1.x*tm1.x + tm1.y*tm1.y + tm1.z*tm1.z);
    tm1.x = tm1.x/nl;
    tm1.z = tm1.y/nl;
    tm1.y = tm1.z/nl;

    n1 = tm1.y*tm2.z-tm1.z*tm2.y;
    n2 =-tm1.x*tm2.z+tm1.z*tm2.x;
    n3 = tm1.x*tm2.y-tm1.y*tm2.x;

    $tm3 = vect3d(n1, n2, n3);
   }

   $rule singleton(tmn1<-tm3), constraint(Gust) {
/*
 *  transformation matrix 
 *    direction of gust propagation
 *    direction normal to gust plane
 *    direction of gust disturbance 
 */
    vect3d tm1 = vect3d(1.0, 0.0, 0.0);
    vect3d tm2 = vect3d(0.0, 1.0, 0.0); 
    $tmn1 = vect3d(tm1.x, tm2.x, $tm3.x);
   }
/*
 * gust propagation velocity
 */
   $rule singleton(Gvel<-gvel), constraint(Gust) {
     $Gvel = sqrt($gvel.x*$gvel.x + $gvel.y*$gvel.y + $gvel.z*$gvel.z);
   }
/*
 * set gust types
 */
  $type GustTypes blackbox<std::set<std::string> > ;

  $rule unit(GustTypes<-gustSpecification),prelude {
    *$GustTypes = std::set<std::string>() ;
  } ;

  $rule apply(GustTypes)[Loci::NullOp],
    constraint(UNIVERSE),prelude {
    $GustTypes->insert(string("oneMcos")) ;
    $GustTypes->insert(string("step")) ;
    $GustTypes->insert(string("prescribed")) ;
  } ;
/*
 * specify constraints for each type of gust
 * gust is specified in entire domain, not per
 * volumeTag
 */ 
  $type GustTypes_oneMcos Constraint ;
  $type GustTypes_step    Constraint ;
  $type GustTypes_prescribed Constraint ;
/*
 * set the proper gust type
 */
  $rule constraint(GustTypes_oneMcos,GustTypes_step,GustTypes_prescribed<-gustSpecification,GustTypes){

    $GustTypes_oneMcos    = EMPTY ;
    $GustTypes_step       = EMPTY ;
    $GustTypes_prescribed = EMPTY ;
    string type;

    Loci::options_list int_info ;
    int_info  = $gustSpecification;
    int_info.getOption("type",type) ;
        
    if(type == "oneMcos") {
      $GustTypes_oneMcos = ~EMPTY ;
    } else if(type == "step") {
      $GustTypes_step = ~EMPTY ;
    } else if(type == "prescribed") {
      $GustTypes_prescribed = ~EMPTY ;
    } else {
      cerr << "Unknown gust type '" << type << "'" << endl ;
      Loci::Abort() ;
    }
  };
/*
 * get parameters for 1-cos gust
 */
  $rule singleton(Ogust,Usg,gnorm,gvel,Lgrad<-gustSpecification),constraint(GustTypes_oneMcos){
    string type;
    real  rpar;
    vect3d vpar;

    Loci::options_list int_info ;
    int_info  = $gustSpecification;
/*
 * get 1-cos gust parameters 
 */
    int_info.getOptionUnits("Lgrad","m", rpar) ;
    $Lgrad = rpar;
    int_info.getOptionUnits("Usg","m/s",rpar) ;
    $Usg = rpar;
    int_info.getOptionUnits("gnorm"," ", vpar,1); 
    $gnorm = vpar;
    int_info.getOptionUnits("gvel","m/s",vpar,1); 
    $gvel = vpar;
    int_info.getOptionUnits("Ogust","m/s",vpar,1); 
    $Ogust = vpar;
  };

/*
 * add artificial velocity due to 1-cos gust to face velocity
 */
  $rule apply(us_n<-dtmax,stime,area,facecenter,tm3,tmn1,Lgrad,Gvel,Usg,Ogust)[Loci::Summation],
    constraint(area,GustTypes_oneMcos){

    real time = $dtmax + $stime;
    real length = $Lgrad;
    real velfree = $Gvel;

    vect3d usv;

    vect3d gust_orig = $Ogust;
    real twopil = 3.1415926 / length ;  // length is so called gradient length
/*
 * interpolate
 */
    real xmin    = velfree * time - 2*length;
    real xmax    = velfree * time;

    real xtmp = ($tmn1.x * ($facecenter.x-gust_orig.x)) +
                        ($tmn1.y * ($facecenter.y-gust_orig.y)) +
                        ($tmn1.z * ($facecenter.z-gust_orig.z));

    if(  (xtmp > xmin ) && (xtmp < xmax)){
       real gvel  = $Usg * (1 - cos(twopil * (xmax - xtmp) ))/2.;
       usv.x = $tm3.x * gvel;
       usv.y = $tm3.y * gvel;
       usv.z = $tm3.z * gvel;
    }else{
       usv = vect3d(0.0, 0.0, 0.0);
    }

    $us_n = -dot(usv,$area.n);
  };

/*
 * get parameters for pulse gust
 */
  $rule singleton(Ogust,Usg,gnorm,gvel<-gustSpecification),constraint(GustTypes_pulse){
    string type;
    real  rpar;
    vect3d vpar;

    Loci::options_list int_info ;
    int_info  = $gustSpecification;
/*
 * get 1-cos gust parameters 
 */
    int_info.getOptionUnits("Usg","m/s",rpar) ;
    $Usg = rpar;
    int_info.getOptionUnits("gnorm"," ", vpar,1); 
    $gnorm = vpar;
    int_info.getOptionUnits("gvel","m/s",vpar,1); 
    $gvel = vpar;
    int_info.getOptionUnits("Ogust","m/s",vpar,1); 
    $Ogust = vpar;
  };
/*
 * add artificial velocity due to pulse gust to face velocity
 */
  $rule apply(us_n<-dtmax,stime,area,facecenter,tm3,tmn1,Gvel,Usg,Ogust)[Loci::Summation],
    constraint(area,GustTypes_pulse){

    real time = $dtmax + $stime;
    real velfree = $Gvel;

    vect3d usv;

    vect3d gust_orig = $Ogust;
/*
 * interpolate
 */
    real xfront    = velfree * time;

    real xtmp = ($tmn1.x * ($facecenter.x-gust_orig.x)) +
                ($tmn1.y * ($facecenter.y-gust_orig.y)) +
                ($tmn1.z * ($facecenter.z-gust_orig.z));

    if(  xtmp < xfront ){
       real gvel  = $Usg;
       usv.x = $tm3.x * gvel;
       usv.y = $tm3.y * gvel;
       usv.z = $tm3.z * gvel;
    }else{
       usv = vect3d(0.0, 0.0, 0.0);
    }

    $us_n = -dot(usv,$area.n);
  };

}
